use crate::pcie::{pcie_id::INTEL_VENDOR_ID, BaseAddress, PCIeInfo};

use super::IgbDriverErr;

const E1000_DEV_ID_82543GC_FIBER: u16 = 0x1001;
const E1000_DEV_ID_82542: u16 = 0x1000;
const E1000_DEV_ID_82543GC_COPPER: u16 = 0x1004;
const E1000_DEV_ID_82544EI_COPPER: u16 = 0x1008;
const E1000_DEV_ID_82544EI_FIBER: u16 = 0x1009;
const E1000_DEV_ID_82544GC_COPPER: u16 = 0x100C;
const E1000_DEV_ID_82544GC_LOM: u16 = 0x100D;
const E1000_DEV_ID_82540EM: u16 = 0x100E;
const E1000_DEV_ID_82540EM_LOM: u16 = 0x1015;
const E1000_DEV_ID_82540EP_LOM: u16 = 0x1016;
const E1000_DEV_ID_82540EP: u16 = 0x1017;
const E1000_DEV_ID_82540EP_LP: u16 = 0x101E;
const E1000_DEV_ID_82545EM_COPPER: u16 = 0x100F;
const E1000_DEV_ID_82545EM_FIBER: u16 = 0x1011;
const E1000_DEV_ID_82545GM_COPPER: u16 = 0x1026;
const E1000_DEV_ID_82545GM_FIBER: u16 = 0x1027;
const E1000_DEV_ID_82545GM_SERDES: u16 = 0x1028;
const E1000_DEV_ID_82546EB_COPPER: u16 = 0x1010;
const E1000_DEV_ID_82546EB_FIBER: u16 = 0x1012;
const E1000_DEV_ID_82546EB_QUAD_COPPER: u16 = 0x101D;
const E1000_DEV_ID_82541EI: u16 = 0x1013;
const E1000_DEV_ID_82541EI_MOBILE: u16 = 0x1018;
const E1000_DEV_ID_82541ER_LOM: u16 = 0x1014;
const E1000_DEV_ID_82541ER: u16 = 0x1078;
const E1000_DEV_ID_82547GI: u16 = 0x1075;
const E1000_DEV_ID_82541GI: u16 = 0x1076;
const E1000_DEV_ID_82541GI_MOBILE: u16 = 0x1077;
const E1000_DEV_ID_82541GI_LF: u16 = 0x107C;
const E1000_DEV_ID_82546GB_COPPER: u16 = 0x1079;
const E1000_DEV_ID_82546GB_FIBER: u16 = 0x107A;
const E1000_DEV_ID_82546GB_SERDES: u16 = 0x107B;
const E1000_DEV_ID_82546GB_PCIE: u16 = 0x108A;
const E1000_DEV_ID_82546GB_QUAD_COPPER: u16 = 0x1099;
const E1000_DEV_ID_82547EI: u16 = 0x1019;
const E1000_DEV_ID_82547EI_MOBILE: u16 = 0x101A;
const E1000_DEV_ID_82571EB_COPPER: u16 = 0x105E;
const E1000_DEV_ID_82571EB_FIBER: u16 = 0x105F;
const E1000_DEV_ID_82571EB_SERDES: u16 = 0x1060;
const E1000_DEV_ID_82571EB_SERDES_DUAL: u16 = 0x10D9;
const E1000_DEV_ID_82571EB_SERDES_QUAD: u16 = 0x10DA;
const E1000_DEV_ID_82571EB_QUAD_COPPER: u16 = 0x10A4;
const E1000_DEV_ID_82571EB_QUAD_FIBER: u16 = 0x10A5;
const E1000_DEV_ID_82571EB_QUAD_COPPER_LP: u16 = 0x10BC;
const E1000_DEV_ID_82571PT_QUAD_COPPER: u16 = 0x10D5;
const E1000_DEV_ID_82572EI_COPPER: u16 = 0x107D;
const E1000_DEV_ID_82572EI_FIBER: u16 = 0x107E;
const E1000_DEV_ID_82572EI_SERDES: u16 = 0x107F;
const E1000_DEV_ID_82572EI: u16 = 0x10B9;
const E1000_DEV_ID_82573E: u16 = 0x108B;
const E1000_DEV_ID_82573E_IAMT: u16 = 0x108C;
const E1000_DEV_ID_82573L: u16 = 0x109A;
const E1000_DEV_ID_82574L: u16 = 0x10D3; // e1000e
const E1000_DEV_ID_82574LA: u16 = 0x10F6;
const E1000_DEV_ID_82546GB_2: u16 = 0x109B;
const E1000_DEV_ID_82571EB_AT: u16 = 0x10A0;
const E1000_DEV_ID_82571EB_AF: u16 = 0x10A1;
const E1000_DEV_ID_82573L_PL_1: u16 = 0x10B0;
const E1000_DEV_ID_82573V_PM: u16 = 0x10B2;
const E1000_DEV_ID_82573E_PM: u16 = 0x10B3;
const E1000_DEV_ID_82573L_PL_2: u16 = 0x10B4;
const E1000_DEV_ID_82546GB_QUAD_COPPER_KSP3: u16 = 0x10B5;
const E1000_DEV_ID_80003ES2LAN_COPPER_DPT: u16 = 0x1096;
const E1000_DEV_ID_80003ES2LAN_SERDES_DPT: u16 = 0x1098;
const E1000_DEV_ID_80003ES2LAN_COPPER_SPT: u16 = 0x10BA;
const E1000_DEV_ID_80003ES2LAN_SERDES_SPT: u16 = 0x10BB;
const E1000_DEV_ID_ICH8_82567V_3: u16 = 0x1501;
const E1000_DEV_ID_ICH8_IGP_M_AMT: u16 = 0x1049;
const E1000_DEV_ID_ICH8_IGP_AMT: u16 = 0x104A;
const E1000_DEV_ID_ICH8_IGP_C: u16 = 0x104B;
const E1000_DEV_ID_ICH8_IFE: u16 = 0x104C;
const E1000_DEV_ID_ICH8_IFE_GT: u16 = 0x10C4;
const E1000_DEV_ID_ICH8_IFE_G: u16 = 0x10C5;
const E1000_DEV_ID_ICH8_IGP_M: u16 = 0x104D;
const E1000_DEV_ID_ICH9_IGP_M: u16 = 0x10BF;
const E1000_DEV_ID_ICH9_IGP_M_AMT: u16 = 0x10F5;
const E1000_DEV_ID_ICH9_IGP_M_V: u16 = 0x10CB;
const E1000_DEV_ID_ICH9_IGP_AMT: u16 = 0x10BD;
const E1000_DEV_ID_ICH9_BM: u16 = 0x10E5;
const E1000_DEV_ID_ICH9_IGP_C: u16 = 0x294C;
const E1000_DEV_ID_ICH9_IFE: u16 = 0x10C0;
const E1000_DEV_ID_ICH9_IFE_GT: u16 = 0x10C3;
const E1000_DEV_ID_ICH9_IFE_G: u16 = 0x10C2;
const E1000_DEV_ID_ICH10_R_BM_LM: u16 = 0x10CC;
const E1000_DEV_ID_ICH10_R_BM_LF: u16 = 0x10CD;
const E1000_DEV_ID_ICH10_R_BM_V: u16 = 0x10CE;
const E1000_DEV_ID_ICH10_D_BM_LM: u16 = 0x10DE;
const E1000_DEV_ID_ICH10_D_BM_LF: u16 = 0x10DF;
const E1000_DEV_ID_ICH10_D_BM_V: u16 = 0x1525;
const E1000_DEV_ID_PCH_M_HV_LM: u16 = 0x10EA;
const E1000_DEV_ID_PCH_M_HV_LC: u16 = 0x10EB;
const E1000_DEV_ID_PCH_D_HV_DM: u16 = 0x10EF;
const E1000_DEV_ID_PCH_D_HV_DC: u16 = 0x10F0;
const E1000_DEV_ID_PCH_LPT_I217_LM: u16 = 0x153A;
const E1000_DEV_ID_PCH_LPT_I217_V: u16 = 0x153B;
const E1000_DEV_ID_PCH_LPTLP_I218_LM: u16 = 0x155A;
const E1000_DEV_ID_PCH_LPTLP_I218_V: u16 = 0x1559;
const E1000_DEV_ID_PCH_I218_LM2: u16 = 0x15A0;
const E1000_DEV_ID_PCH_I218_V2: u16 = 0x15A1;
const E1000_DEV_ID_PCH_I218_LM3: u16 = 0x15A2;
const E1000_DEV_ID_PCH_I218_V3: u16 = 0x15A3;
const E1000_DEV_ID_PCH_SPT_I219_LM: u16 = 0x156F;
const E1000_DEV_ID_PCH_SPT_I219_V: u16 = 0x1570;
const E1000_DEV_ID_PCH_SPT_I219_LM2: u16 = 0x15B7;
const E1000_DEV_ID_PCH_SPT_I219_V2: u16 = 0x15B8;
const E1000_DEV_ID_PCH_LBG_I219_LM3: u16 = 0x15B9;
const E1000_DEV_ID_PCH_SPT_I219_LM4: u16 = 0x15D7;
const E1000_DEV_ID_PCH_SPT_I219_V4: u16 = 0x15D8;
const E1000_DEV_ID_PCH_SPT_I219_LM5: u16 = 0x15E3;
const E1000_DEV_ID_PCH_SPT_I219_V5: u16 = 0x15D6;
const E1000_DEV_ID_PCH_CNP_I219_LM6: u16 = 0x15BD;
const E1000_DEV_ID_PCH_CNP_I219_V6: u16 = 0x15BE;
const E1000_DEV_ID_PCH_CNP_I219_LM7: u16 = 0x15BB;
const E1000_DEV_ID_PCH_CNP_I219_V7: u16 = 0x15BC;
const E1000_DEV_ID_PCH_ICP_I219_LM8: u16 = 0x15DF;
const E1000_DEV_ID_PCH_ICP_I219_V8: u16 = 0x15E0;
const E1000_DEV_ID_PCH_ICP_I219_LM9: u16 = 0x15E1;
const E1000_DEV_ID_PCH_ICP_I219_V9: u16 = 0x15E2;
const E1000_DEV_ID_PCH_CMP_I219_LM10: u16 = 0x0D4E;
const E1000_DEV_ID_PCH_CMP_I219_V10: u16 = 0x0D4F;
const E1000_DEV_ID_PCH_CMP_I219_LM11: u16 = 0x0D4C;
const E1000_DEV_ID_PCH_CMP_I219_V11: u16 = 0x0D4D;
const E1000_DEV_ID_PCH_CMP_I219_LM12: u16 = 0x0D53;
const E1000_DEV_ID_PCH_CMP_I219_V12: u16 = 0x0D55;
const E1000_DEV_ID_PCH_TGP_I219_LM13: u16 = 0x15FB;
const E1000_DEV_ID_PCH_TGP_I219_V13: u16 = 0x15FC;
const E1000_DEV_ID_PCH_TGP_I219_LM14: u16 = 0x15F9;
const E1000_DEV_ID_PCH_TGP_I219_V14: u16 = 0x15FA;
const E1000_DEV_ID_PCH_TGP_I219_LM15: u16 = 0x15F4;
const E1000_DEV_ID_PCH_TGP_I219_V15: u16 = 0x15F5;
const E1000_DEV_ID_PCH_ADP_I219_LM16: u16 = 0x1A1E;
const E1000_DEV_ID_PCH_ADP_I219_V16: u16 = 0x1A1F;
const E1000_DEV_ID_PCH_ADP_I219_LM17: u16 = 0x1A1C;
const E1000_DEV_ID_PCH_ADP_I219_V17: u16 = 0x1A1D;
const E1000_DEV_ID_PCH_MTP_I219_LM18: u16 = 0x550A;
const E1000_DEV_ID_PCH_MTP_I219_V18: u16 = 0x550B;
const E1000_DEV_ID_PCH_MTP_I219_LM19: u16 = 0x550C;
const E1000_DEV_ID_PCH_MTP_I219_V19: u16 = 0x550D;
const E1000_DEV_ID_82575EB_PT: u16 = 0x10A7;
const E1000_DEV_ID_82575EB_PF: u16 = 0x10A9;
const E1000_DEV_ID_82575GB_QP: u16 = 0x10D6;
const E1000_DEV_ID_82575GB_QP_PM: u16 = 0x10E2;
const E1000_DEV_ID_82576: u16 = 0x10C9;
const E1000_DEV_ID_82576_FIBER: u16 = 0x10E6;
const E1000_DEV_ID_82576_SERDES: u16 = 0x10E7;
const E1000_DEV_ID_82576_QUAD_COPPER: u16 = 0x10E8;
const E1000_DEV_ID_82576_NS: u16 = 0x150A;
const E1000_DEV_ID_82583V: u16 = 0x150C;
const E1000_DEV_ID_82576_NS_SERDES: u16 = 0x1518;
const E1000_DEV_ID_82576_SERDES_QUAD: u16 = 0x150D;
const E1000_DEV_ID_PCH2_LV_LM: u16 = 0x1502;
const E1000_DEV_ID_PCH2_LV_V: u16 = 0x1503;
const E1000_DEV_ID_82580_COPPER: u16 = 0x150E;
const E1000_DEV_ID_82580_FIBER: u16 = 0x150F;
const E1000_DEV_ID_82580_SERDES: u16 = 0x1510;
const E1000_DEV_ID_82580_SGMII: u16 = 0x1511;
const E1000_DEV_ID_82580_COPPER_DUAL: u16 = 0x1516;
const E1000_DEV_ID_82580_QUAD_FIBER: u16 = 0x1527;
const E1000_DEV_ID_DH89XXCC_SGMII: u16 = 0x0438;
const E1000_DEV_ID_DH89XXCC_SERDES: u16 = 0x043A;
const E1000_DEV_ID_DH89XXCC_BACKPLANE: u16 = 0x043C;
const E1000_DEV_ID_DH89XXCC_SFP: u16 = 0x0440;
const E1000_DEV_ID_I350_COPPER: u16 = 0x1521;
const E1000_DEV_ID_I350_FIBER: u16 = 0x1522;
const E1000_DEV_ID_I350_SERDES: u16 = 0x1523;
const E1000_DEV_ID_I350_SGMII: u16 = 0x1524;
const E1000_DEV_ID_82576_QUAD_CU_ET2: u16 = 0x1526;
const E1000_DEV_ID_I210_COPPER: u16 = 0x1533;
const E1000_DEV_ID_I210_COPPER_OEM1: u16 = 0x1534;
const E1000_DEV_ID_I210_COPPER_IT: u16 = 0x1535;
const E1000_DEV_ID_I210_FIBER: u16 = 0x1536;
const E1000_DEV_ID_I210_SERDES: u16 = 0x1537;
const E1000_DEV_ID_I210_SGMII: u16 = 0x1538;
const E1000_DEV_ID_I210_COPPER_FLASHLESS: u16 = 0x157B;
const E1000_DEV_ID_I210_SERDES_FLASHLESS: u16 = 0x157C;
const E1000_DEV_ID_I211_COPPER: u16 = 0x1539;
const E1000_DEV_ID_I350_DA4: u16 = 0x1546;
const E1000_DEV_ID_I354_BACKPLANE_1GBPS: u16 = 0x1F40;
const E1000_DEV_ID_I354_SGMII: u16 = 0x1F41;
const E1000_DEV_ID_I354_BACKPLANE_2_5GBPS: u16 = 0x1F45;
const E1000_DEV_ID_EP80579_LAN_1: u16 = 0x5040;
const E1000_DEV_ID_EP80579_LAN_2: u16 = 0x5044;
const E1000_DEV_ID_EP80579_LAN_3: u16 = 0x5048;
const E1000_DEV_ID_EP80579_LAN_4: u16 = 0x5041;
const E1000_DEV_ID_EP80579_LAN_5: u16 = 0x5045;
const E1000_DEV_ID_EP80579_LAN_6: u16 = 0x5049;

const E1000_82542_2_0_REV_ID: u8 = 2;
const E1000_82542_2_1_REV_ID: u8 = 3;

pub const E1000_DEVICES: [(u16, u16); 185] = [
    (INTEL_VENDOR_ID, E1000_DEV_ID_82543GC_FIBER),
    (INTEL_VENDOR_ID, E1000_DEV_ID_82542),
    (INTEL_VENDOR_ID, E1000_DEV_ID_82543GC_COPPER),
    (INTEL_VENDOR_ID, E1000_DEV_ID_82544EI_COPPER),
    (INTEL_VENDOR_ID, E1000_DEV_ID_82544EI_FIBER),
    (INTEL_VENDOR_ID, E1000_DEV_ID_82544GC_COPPER),
    (INTEL_VENDOR_ID, E1000_DEV_ID_82544GC_LOM),
    (INTEL_VENDOR_ID, E1000_DEV_ID_82540EM),
    (INTEL_VENDOR_ID, E1000_DEV_ID_82540EM_LOM),
    (INTEL_VENDOR_ID, E1000_DEV_ID_82540EP_LOM),
    (INTEL_VENDOR_ID, E1000_DEV_ID_82540EP),
    (INTEL_VENDOR_ID, E1000_DEV_ID_82540EP_LP),
    (INTEL_VENDOR_ID, E1000_DEV_ID_82545EM_COPPER),
    (INTEL_VENDOR_ID, E1000_DEV_ID_82545EM_FIBER),
    (INTEL_VENDOR_ID, E1000_DEV_ID_82545GM_COPPER),
    (INTEL_VENDOR_ID, E1000_DEV_ID_82545GM_FIBER),
    (INTEL_VENDOR_ID, E1000_DEV_ID_82545GM_SERDES),
    (INTEL_VENDOR_ID, E1000_DEV_ID_82546EB_COPPER),
    (INTEL_VENDOR_ID, E1000_DEV_ID_82546EB_FIBER),
    (INTEL_VENDOR_ID, E1000_DEV_ID_82546EB_QUAD_COPPER),
    (INTEL_VENDOR_ID, E1000_DEV_ID_82541EI),
    (INTEL_VENDOR_ID, E1000_DEV_ID_82541EI_MOBILE),
    (INTEL_VENDOR_ID, E1000_DEV_ID_82541ER_LOM),
    (INTEL_VENDOR_ID, E1000_DEV_ID_82541ER),
    (INTEL_VENDOR_ID, E1000_DEV_ID_82547GI),
    (INTEL_VENDOR_ID, E1000_DEV_ID_82541GI),
    (INTEL_VENDOR_ID, E1000_DEV_ID_82541GI_MOBILE),
    (INTEL_VENDOR_ID, E1000_DEV_ID_82541GI_LF),
    (INTEL_VENDOR_ID, E1000_DEV_ID_82546GB_COPPER),
    (INTEL_VENDOR_ID, E1000_DEV_ID_82546GB_FIBER),
    (INTEL_VENDOR_ID, E1000_DEV_ID_82546GB_SERDES),
    (INTEL_VENDOR_ID, E1000_DEV_ID_82546GB_PCIE),
    (INTEL_VENDOR_ID, E1000_DEV_ID_82546GB_QUAD_COPPER),
    (INTEL_VENDOR_ID, E1000_DEV_ID_82547EI),
    (INTEL_VENDOR_ID, E1000_DEV_ID_82547EI_MOBILE),
    (INTEL_VENDOR_ID, E1000_DEV_ID_82571EB_COPPER),
    (INTEL_VENDOR_ID, E1000_DEV_ID_82571EB_FIBER),
    (INTEL_VENDOR_ID, E1000_DEV_ID_82571EB_SERDES),
    (INTEL_VENDOR_ID, E1000_DEV_ID_82571EB_SERDES_DUAL),
    (INTEL_VENDOR_ID, E1000_DEV_ID_82571EB_SERDES_QUAD),
    (INTEL_VENDOR_ID, E1000_DEV_ID_82571EB_QUAD_COPPER),
    (INTEL_VENDOR_ID, E1000_DEV_ID_82571EB_QUAD_FIBER),
    (INTEL_VENDOR_ID, E1000_DEV_ID_82571EB_QUAD_COPPER_LP),
    (INTEL_VENDOR_ID, E1000_DEV_ID_82571PT_QUAD_COPPER),
    (INTEL_VENDOR_ID, E1000_DEV_ID_82572EI_COPPER),
    (INTEL_VENDOR_ID, E1000_DEV_ID_82572EI_FIBER),
    (INTEL_VENDOR_ID, E1000_DEV_ID_82572EI_SERDES),
    (INTEL_VENDOR_ID, E1000_DEV_ID_82572EI),
    (INTEL_VENDOR_ID, E1000_DEV_ID_82573E),
    (INTEL_VENDOR_ID, E1000_DEV_ID_82573E_IAMT),
    (INTEL_VENDOR_ID, E1000_DEV_ID_82573L),
    (INTEL_VENDOR_ID, E1000_DEV_ID_82574L),
    (INTEL_VENDOR_ID, E1000_DEV_ID_82574LA),
    (INTEL_VENDOR_ID, E1000_DEV_ID_82546GB_2),
    (INTEL_VENDOR_ID, E1000_DEV_ID_82571EB_AT),
    (INTEL_VENDOR_ID, E1000_DEV_ID_82571EB_AF),
    (INTEL_VENDOR_ID, E1000_DEV_ID_82573L_PL_1),
    (INTEL_VENDOR_ID, E1000_DEV_ID_82573V_PM),
    (INTEL_VENDOR_ID, E1000_DEV_ID_82573E_PM),
    (INTEL_VENDOR_ID, E1000_DEV_ID_82573L_PL_2),
    (INTEL_VENDOR_ID, E1000_DEV_ID_82546GB_QUAD_COPPER_KSP3),
    (INTEL_VENDOR_ID, E1000_DEV_ID_80003ES2LAN_COPPER_DPT),
    (INTEL_VENDOR_ID, E1000_DEV_ID_80003ES2LAN_SERDES_DPT),
    (INTEL_VENDOR_ID, E1000_DEV_ID_80003ES2LAN_COPPER_SPT),
    (INTEL_VENDOR_ID, E1000_DEV_ID_80003ES2LAN_SERDES_SPT),
    (INTEL_VENDOR_ID, E1000_DEV_ID_ICH8_82567V_3),
    (INTEL_VENDOR_ID, E1000_DEV_ID_ICH8_IGP_M_AMT),
    (INTEL_VENDOR_ID, E1000_DEV_ID_ICH8_IGP_AMT),
    (INTEL_VENDOR_ID, E1000_DEV_ID_ICH8_IGP_C),
    (INTEL_VENDOR_ID, E1000_DEV_ID_ICH8_IFE),
    (INTEL_VENDOR_ID, E1000_DEV_ID_ICH8_IFE_GT),
    (INTEL_VENDOR_ID, E1000_DEV_ID_ICH8_IFE_G),
    (INTEL_VENDOR_ID, E1000_DEV_ID_ICH8_IGP_M),
    (INTEL_VENDOR_ID, E1000_DEV_ID_ICH9_IGP_M),
    (INTEL_VENDOR_ID, E1000_DEV_ID_ICH9_IGP_M_AMT),
    (INTEL_VENDOR_ID, E1000_DEV_ID_ICH9_IGP_M_V),
    (INTEL_VENDOR_ID, E1000_DEV_ID_ICH9_IGP_AMT),
    (INTEL_VENDOR_ID, E1000_DEV_ID_ICH9_BM),
    (INTEL_VENDOR_ID, E1000_DEV_ID_ICH9_IGP_C),
    (INTEL_VENDOR_ID, E1000_DEV_ID_ICH9_IFE),
    (INTEL_VENDOR_ID, E1000_DEV_ID_ICH9_IFE_GT),
    (INTEL_VENDOR_ID, E1000_DEV_ID_ICH9_IFE_G),
    (INTEL_VENDOR_ID, E1000_DEV_ID_ICH10_R_BM_LM),
    (INTEL_VENDOR_ID, E1000_DEV_ID_ICH10_R_BM_LF),
    (INTEL_VENDOR_ID, E1000_DEV_ID_ICH10_R_BM_V),
    (INTEL_VENDOR_ID, E1000_DEV_ID_ICH10_D_BM_LM),
    (INTEL_VENDOR_ID, E1000_DEV_ID_ICH10_D_BM_LF),
    (INTEL_VENDOR_ID, E1000_DEV_ID_ICH10_D_BM_V),
    (INTEL_VENDOR_ID, E1000_DEV_ID_PCH_M_HV_LM),
    (INTEL_VENDOR_ID, E1000_DEV_ID_PCH_M_HV_LC),
    (INTEL_VENDOR_ID, E1000_DEV_ID_PCH_D_HV_DM),
    (INTEL_VENDOR_ID, E1000_DEV_ID_PCH_D_HV_DC),
    (INTEL_VENDOR_ID, E1000_DEV_ID_PCH_LPT_I217_LM),
    (INTEL_VENDOR_ID, E1000_DEV_ID_PCH_LPT_I217_V),
    (INTEL_VENDOR_ID, E1000_DEV_ID_PCH_LPTLP_I218_LM),
    (INTEL_VENDOR_ID, E1000_DEV_ID_PCH_LPTLP_I218_V),
    (INTEL_VENDOR_ID, E1000_DEV_ID_PCH_I218_LM2),
    (INTEL_VENDOR_ID, E1000_DEV_ID_PCH_I218_V2),
    (INTEL_VENDOR_ID, E1000_DEV_ID_PCH_I218_LM3),
    (INTEL_VENDOR_ID, E1000_DEV_ID_PCH_I218_V3),
    (INTEL_VENDOR_ID, E1000_DEV_ID_PCH_SPT_I219_LM),
    (INTEL_VENDOR_ID, E1000_DEV_ID_PCH_SPT_I219_V),
    (INTEL_VENDOR_ID, E1000_DEV_ID_PCH_SPT_I219_LM2),
    (INTEL_VENDOR_ID, E1000_DEV_ID_PCH_SPT_I219_V2),
    (INTEL_VENDOR_ID, E1000_DEV_ID_PCH_LBG_I219_LM3),
    (INTEL_VENDOR_ID, E1000_DEV_ID_PCH_SPT_I219_LM4),
    (INTEL_VENDOR_ID, E1000_DEV_ID_PCH_SPT_I219_V4),
    (INTEL_VENDOR_ID, E1000_DEV_ID_PCH_SPT_I219_LM5),
    (INTEL_VENDOR_ID, E1000_DEV_ID_PCH_SPT_I219_V5),
    (INTEL_VENDOR_ID, E1000_DEV_ID_PCH_CNP_I219_LM6),
    (INTEL_VENDOR_ID, E1000_DEV_ID_PCH_CNP_I219_V6),
    (INTEL_VENDOR_ID, E1000_DEV_ID_PCH_CNP_I219_LM7),
    (INTEL_VENDOR_ID, E1000_DEV_ID_PCH_CNP_I219_V7),
    (INTEL_VENDOR_ID, E1000_DEV_ID_PCH_ICP_I219_LM8),
    (INTEL_VENDOR_ID, E1000_DEV_ID_PCH_ICP_I219_V8),
    (INTEL_VENDOR_ID, E1000_DEV_ID_PCH_ICP_I219_LM9),
    (INTEL_VENDOR_ID, E1000_DEV_ID_PCH_ICP_I219_V9),
    (INTEL_VENDOR_ID, E1000_DEV_ID_PCH_CMP_I219_LM10),
    (INTEL_VENDOR_ID, E1000_DEV_ID_PCH_CMP_I219_V10),
    (INTEL_VENDOR_ID, E1000_DEV_ID_PCH_CMP_I219_LM11),
    (INTEL_VENDOR_ID, E1000_DEV_ID_PCH_CMP_I219_V11),
    (INTEL_VENDOR_ID, E1000_DEV_ID_PCH_CMP_I219_LM12),
    (INTEL_VENDOR_ID, E1000_DEV_ID_PCH_CMP_I219_V12),
    (INTEL_VENDOR_ID, E1000_DEV_ID_PCH_TGP_I219_LM13),
    (INTEL_VENDOR_ID, E1000_DEV_ID_PCH_TGP_I219_V13),
    (INTEL_VENDOR_ID, E1000_DEV_ID_PCH_TGP_I219_LM14),
    (INTEL_VENDOR_ID, E1000_DEV_ID_PCH_TGP_I219_V14),
    (INTEL_VENDOR_ID, E1000_DEV_ID_PCH_TGP_I219_LM15),
    (INTEL_VENDOR_ID, E1000_DEV_ID_PCH_TGP_I219_V15),
    (INTEL_VENDOR_ID, E1000_DEV_ID_PCH_ADP_I219_LM16),
    (INTEL_VENDOR_ID, E1000_DEV_ID_PCH_ADP_I219_V16),
    (INTEL_VENDOR_ID, E1000_DEV_ID_PCH_ADP_I219_LM17),
    (INTEL_VENDOR_ID, E1000_DEV_ID_PCH_ADP_I219_V17),
    (INTEL_VENDOR_ID, E1000_DEV_ID_PCH_MTP_I219_LM18),
    (INTEL_VENDOR_ID, E1000_DEV_ID_PCH_MTP_I219_V18),
    (INTEL_VENDOR_ID, E1000_DEV_ID_PCH_MTP_I219_LM19),
    (INTEL_VENDOR_ID, E1000_DEV_ID_PCH_MTP_I219_V19),
    (INTEL_VENDOR_ID, E1000_DEV_ID_82575EB_PT),
    (INTEL_VENDOR_ID, E1000_DEV_ID_82575EB_PF),
    (INTEL_VENDOR_ID, E1000_DEV_ID_82575GB_QP),
    (INTEL_VENDOR_ID, E1000_DEV_ID_82575GB_QP_PM),
    (INTEL_VENDOR_ID, E1000_DEV_ID_82576),
    (INTEL_VENDOR_ID, E1000_DEV_ID_82576_FIBER),
    (INTEL_VENDOR_ID, E1000_DEV_ID_82576_SERDES),
    (INTEL_VENDOR_ID, E1000_DEV_ID_82576_QUAD_COPPER),
    (INTEL_VENDOR_ID, E1000_DEV_ID_82576_NS),
    (INTEL_VENDOR_ID, E1000_DEV_ID_82583V),
    (INTEL_VENDOR_ID, E1000_DEV_ID_82576_NS_SERDES),
    (INTEL_VENDOR_ID, E1000_DEV_ID_82576_SERDES_QUAD),
    (INTEL_VENDOR_ID, E1000_DEV_ID_PCH2_LV_LM),
    (INTEL_VENDOR_ID, E1000_DEV_ID_PCH2_LV_V),
    (INTEL_VENDOR_ID, E1000_DEV_ID_82580_COPPER),
    (INTEL_VENDOR_ID, E1000_DEV_ID_82580_FIBER),
    (INTEL_VENDOR_ID, E1000_DEV_ID_82580_SERDES),
    (INTEL_VENDOR_ID, E1000_DEV_ID_82580_SGMII),
    (INTEL_VENDOR_ID, E1000_DEV_ID_82580_COPPER_DUAL),
    (INTEL_VENDOR_ID, E1000_DEV_ID_82580_QUAD_FIBER),
    (INTEL_VENDOR_ID, E1000_DEV_ID_DH89XXCC_SGMII),
    (INTEL_VENDOR_ID, E1000_DEV_ID_DH89XXCC_SERDES),
    (INTEL_VENDOR_ID, E1000_DEV_ID_DH89XXCC_BACKPLANE),
    (INTEL_VENDOR_ID, E1000_DEV_ID_DH89XXCC_SFP),
    (INTEL_VENDOR_ID, E1000_DEV_ID_I350_COPPER),
    (INTEL_VENDOR_ID, E1000_DEV_ID_I350_FIBER),
    (INTEL_VENDOR_ID, E1000_DEV_ID_I350_SERDES),
    (INTEL_VENDOR_ID, E1000_DEV_ID_I350_SGMII),
    (INTEL_VENDOR_ID, E1000_DEV_ID_82576_QUAD_CU_ET2),
    (INTEL_VENDOR_ID, E1000_DEV_ID_I210_COPPER),
    (INTEL_VENDOR_ID, E1000_DEV_ID_I210_COPPER_OEM1),
    (INTEL_VENDOR_ID, E1000_DEV_ID_I210_COPPER_IT),
    (INTEL_VENDOR_ID, E1000_DEV_ID_I210_FIBER),
    (INTEL_VENDOR_ID, E1000_DEV_ID_I210_SERDES),
    (INTEL_VENDOR_ID, E1000_DEV_ID_I210_SGMII),
    (INTEL_VENDOR_ID, E1000_DEV_ID_I210_COPPER_FLASHLESS),
    (INTEL_VENDOR_ID, E1000_DEV_ID_I210_SERDES_FLASHLESS),
    (INTEL_VENDOR_ID, E1000_DEV_ID_I211_COPPER),
    (INTEL_VENDOR_ID, E1000_DEV_ID_I350_DA4),
    (INTEL_VENDOR_ID, E1000_DEV_ID_I354_BACKPLANE_1GBPS),
    (INTEL_VENDOR_ID, E1000_DEV_ID_I354_SGMII),
    (INTEL_VENDOR_ID, E1000_DEV_ID_I354_BACKPLANE_2_5GBPS),
    (INTEL_VENDOR_ID, E1000_DEV_ID_EP80579_LAN_1),
    (INTEL_VENDOR_ID, E1000_DEV_ID_EP80579_LAN_2),
    (INTEL_VENDOR_ID, E1000_DEV_ID_EP80579_LAN_3),
    (INTEL_VENDOR_ID, E1000_DEV_ID_EP80579_LAN_4),
    (INTEL_VENDOR_ID, E1000_DEV_ID_EP80579_LAN_5),
    (INTEL_VENDOR_ID, E1000_DEV_ID_EP80579_LAN_6),
];

// PHY 1000 MII Register/Bit Definitions
// PHY Registers defined by IEEE
const PHY_CTRL: u32 = 0x00; // Control Register
const PHY_STATUS: u32 = 0x01; // Status Register
const PHY_ID1: u32 = 0x02; // Phy Id Reg (word 1)
const PHY_ID2: u32 = 0x03; // Phy Id Reg (word 2)
const PHY_AUTONEG_ADV: u32 = 0x04; // Autoneg Advertisement
const PHY_LP_ABILITY: u32 = 0x05; // Link Partner Ability (Base Page)
const PHY_AUTONEG_EXP: u32 = 0x06; // Autoneg Expansion Reg
const PHY_NEXT_PAGE_TX: u32 = 0x07; // Next Page TX
const PHY_LP_NEXT_PAGE: u32 = 0x08; // Link Partner Next Page
const PHY_1000T_CTRL: u32 = 0x09; // 1000Base-T Control Reg
const PHY_1000T_STATUS: u32 = 0x0A; // 1000Base-T Status Reg
const PHY_EXT_STATUS: u32 = 0x0F; // Extended Status Reg

// PBA constants
const E1000_PBA_8K: u32 = 0x0008; /* 8KB, default Rx allocation */
const _E1000_PBA_10K: u32 = 0x000A;
const _E1000_PBA_12K: u32 = 0x000C; /* 12KB, default Rx allocation */
const _E1000_PBA_14K: u32 = 0x000E; /* 14KB */
const E1000_PBA_16K: u32 = 0x0010; /* 16KB, default TX allocation */
const _E1000_PBA_20K: u32 = 0x0014;
const _E1000_PBA_22K: u32 = 0x0016;
const _E1000_PBA_24K: u32 = 0x0018;
const _E1000_PBA_26K: u32 = 0x001A;
const _E1000_PBA_30K: u32 = 0x001E;
const _E1000_PBA_32K: u32 = 0x0020;
const _E1000_PBA_34K: u32 = 0x0022;
const _E1000_PBA_38K: u32 = 0x0026;
const _E1000_PBA_40K: u32 = 0x0028;
const _E1000_PBA_48K: u32 = 0x0030; /* 48KB, default RX allocation */

const E1000_PBS_16K: u32 = E1000_PBA_16K;

const SW_FLAG_TIMEOUT: usize = 100;

const MAX_PHY_REG_ADDRESS: u32 = 0x1F; // 5 bit address bus (0-0x1F)
const MAX_PHY_MULTI_PAGE_REG: u32 = 0xF; // Registers equal on all pages

// IGP01E1000 Specific Registers
const _IGP01E1000_PHY_PORT_CONFIG: u32 = 0x10; /* PHY Specific Port Config Register */
const _IGP01E1000_PHY_PORT_STATUS: u32 = 0x11; /* PHY Specific Status Register */
const _IGP01E1000_PHY_PORT_CTRL: u32 = 0x12; /* PHY Specific Control Register */
const _IGP01E1000_PHY_LINK_HEALTH: u32 = 0x13; /* PHY Link Health Register */
const _IGP01E1000_GMII_FIFO: u32 = 0x14; /* GMII FIFO Register */
const _IGP01E1000_PHY_CHANNEL_QUALITY: u32 = 0x15; /* PHY Channel Quality Register */
const _IGP02E1000_PHY_POWER_MGMT: u32 = 0x19;
const IGP01E1000_PHY_PAGE_SELECT: u32 = 0x1F; /* PHY Page Select Core Register */

// BM/HV Specific Registers
const BM_PORT_CTRL_PAGE: u32 = 769;
const _BM_PCIE_PAGE: u16 = 770;
const BM_WUC_PAGE: u16 = 800;
const BM_WUC_ADDRESS_OPCODE: u32 = 0x11;
const BM_WUC_DATA_OPCODE: u32 = 0x12;
const BM_WUC_ENABLE_PAGE: u16 = BM_PORT_CTRL_PAGE as u16;
const BM_WUC_ENABLE_REG: u32 = 17;
const BM_WUC_ENABLE_BIT: u16 = 1 << 2;
const BM_WUC_HOST_WU_BIT: u16 = 1 << 4;

const PHY_PAGE_SHIFT: u32 = 5;
const PHY_UPPER_SHIFT: u32 = 21;

// SW_W_SYNC definitions
const SWFW_EEP_SM: u16 = 0x0001;
const SWFW_PHY0_SM: u16 = 0x0002;
const SWFW_PHY1_SM: u16 = 0x0004;
const _SWFW_MAC_CSR_SM: u16 = 0x0008;
const SWFW_PHY2_SM: u16 = 0x0020;
const SWFW_PHY3_SM: u16 = 0x0040;

// Hanksville definitions
const HV_INTC_FC_PAGE_START: u16 = 768;

const _HV_SCC_UPPER: u32 = phy_reg(778, 16); /* Single Collision Count */
const _HV_SCC_LOWER: u32 = phy_reg(778, 17);
const _HV_ECOL_UPPER: u32 = phy_reg(778, 18); /* Excessive Collision Count */
const _HV_ECOL_LOWER: u32 = phy_reg(778, 19);
const _HV_MCC_UPPER: u32 = phy_reg(778, 20); /* Multiple Collision Count */
const _HV_MCC_LOWER: u32 = phy_reg(778, 21);
const _HV_LATECOL_UPPER: u32 = phy_reg(778, 23); /* Late Collision Count */
const _HV_LATECOL_LOWER: u32 = phy_reg(778, 24);
const _HV_COLC_UPPER: u32 = phy_reg(778, 25); /* Collision Count */
const _HV_COLC_LOWER: u32 = phy_reg(778, 26);
const _HV_DC_UPPER: u32 = phy_reg(778, 27); /* Defer Count */
const _HV_DC_LOWER: u32 = phy_reg(778, 28);
const _HV_TNCRS_UPPER: u32 = phy_reg(778, 29); /* Transmit with no CRS */
const _HV_TNCRS_LOWER: u32 = phy_reg(778, 30);

// I82577 Specific Registers
const I82577_PHY_ADDR_REG: u32 = 16;
const _I82577_PHY_CFG_REG: u32 = 22;
const _I82577_PHY_CTRL_REG: u32 = 23;

// I82578 Specific Registers
const I82578_PHY_ADDR_REG: u32 = 29;

// Bit definitions for valid PHY IDs.
// I = Integrated
// E = External
const M88_VENDOR: u32 = 0x0141;
const M88E1000_E_PHY_ID: u32 = 0x01410C50;
const M88E1000_I_PHY_ID: u32 = 0x01410C30;
const M88E1011_I_PHY_ID: u32 = 0x01410C20;
const IGP01E1000_I_PHY_ID: u32 = 0x02A80380;
const M88E1000_12_PHY_ID: u32 = M88E1000_E_PHY_ID;
const M88E1000_14_PHY_ID: u32 = M88E1000_E_PHY_ID;
const M88E1011_I_REV_4: u32 = 0x04;
const M88E1111_I_PHY_ID: u32 = 0x01410CC0;
const M88E1112_E_PHY_ID: u32 = 0x01410C90;
const I347AT4_E_PHY_ID: u32 = 0x01410DC0;
const L1LXT971A_PHY_ID: u32 = 0x001378E0;
const GG82563_E_PHY_ID: u32 = 0x01410CA0;
const BME1000_E_PHY_ID: u32 = 0x01410CB0;
const BME1000_E_PHY_ID_R2: u32 = 0x01410CB1;
const M88E1543_E_PHY_ID: u32 = 0x01410EA0;
const I82577_E_PHY_ID: u32 = 0x01540050;
const I82578_E_PHY_ID: u32 = 0x004DD040;
const I82579_E_PHY_ID: u32 = 0x01540090;
const I217_E_PHY_ID: u32 = 0x015400A0;
const I82580_I_PHY_ID: u32 = 0x015403A0;
const I350_I_PHY_ID: u32 = 0x015403B0;
const I210_I_PHY_ID: u32 = 0x01410C00;
const IGP04E1000_E_PHY_ID: u32 = 0x02A80391;
const M88E1141_E_PHY_ID: u32 = 0x01410CD0;
const M88E1512_E_PHY_ID: u32 = 0x01410DD0;

const IGP03E1000_E_PHY_ID: u32 = 0x02A80390;
const IFE_E_PHY_ID: u32 = 0x02A80330; // 10/100 PHY
const IFE_PLUS_E_PHY_ID: u32 = 0x02A80320;
const IFE_C_E_PHY_ID: u32 = 0x02A80310;

const RTL8211_E_PHY_ID: u32 = 0x001CC912;

const GG82563_PAGE_SHIFT: u32 = 5;
const GG82563_MIN_ALT_REG: u32 = 30;
const GG82563_PHY_PAGE_SELECT: u32 = gg82563_reg(0, 22); // Page Select
const GG82563_PHY_PAGE_SELECT_ALT: u32 = gg82563_reg(0, 29); // Alternate Page Select

// BME1000 PHY Specific Control Register
const BME1000_PSCR_ENABLE_DOWNSHIFT: u32 = 0x0800; /* 1 = enable downshift */
const BM_PHY_PAGE_SELECT: u32 = 22; /* Page Select for BM */
const BM_REG_BIAS1: u32 = 29;
const BM_REG_BIAS2: u32 = 30;

// Miscellaneous PHY bit definitions.
const PHY_PREAMBLE: u32 = 0xFFFFFFFF;
const PHY_SOF: u32 = 0x01;
const PHY_OP_READ: u32 = 0x02;
const PHY_OP_WRITE: u32 = 0x01;
const PHY_TURNAROUND: u32 = 0x02;
const PHY_PREAMBLE_SIZE: u32 = 32;
const MII_CR_SPEED_1000: u32 = 0x0040;
const MII_CR_SPEED_100: u32 = 0x2000;
const MII_CR_SPEED_10: u32 = 0x0000;
const E1000_PHY_ADDRESS: u32 = 0x01;
const PHY_AUTO_NEG_TIME: u32 = 45; /* 4.5 Seconds */
const PHY_FORCE_TIME: u32 = 20; /* 2.0 Seconds */
const PHY_REVISION_MASK: u32 = 0xFFFFFFF0;
const DEVICE_SPEED_MASK: u32 = 0x00000300; /* Device Ctrl Reg Speed Mask */
const REG4_SPEED_MASK: u32 = 0x01E0;
const REG9_SPEED_MASK: u32 = 0x0300;
const ADVERTISE_10_HALF: u32 = 0x0001;
const ADVERTISE_10_FULL: u32 = 0x0002;
const ADVERTISE_100_HALF: u32 = 0x0004;
const ADVERTISE_100_FULL: u32 = 0x0008;
const ADVERTISE_1000_HALF: u32 = 0x0010;
const ADVERTISE_1000_FULL: u32 = 0x0020;
const AUTONEG_ADVERTISE_SPEED_DEFAULT: u32 = 0x002F; /* Everything but 1000-Half */
const AUTONEG_ADVERTISE_10_100_ALL: u32 = 0x000F; /* All 10/100 speeds*/
const AUTONEG_ADVERTISE_10_ALL: u32 = 0x0003; /* 10Mbps Full & Half speeds*/

const HV_KMRN_MODE_CTRL: u32 = phy_reg(769, 16);
const HV_KMRN_MDIO_SLOW: u32 = 0x0400;

// EMI Registers
const I82579_EMI_ADDR: u32 = 0x10;
const I82579_EMI_DATA: u32 = 0x11;
const I82579_LPI_UPDATE_TIMER: u32 = 0x4805; /* in 40ns units + 40 ns base value */
const I82579_MSE_THRESHOLD: u16 = 0x084F; /* Mean Square Error Threshold */
const I82579_MSE_LINK_DOWN: u16 = 0x2411; /* MSE count before dropping link */

const LEDCTL: usize = 0x00E00;

const IGP_ACTIVITY_LED_MASK: u32 = 0xFFFFF0FF;
const IGP_ACTIVITY_LED_ENABLE: u32 = 0x0300;
const IGP_LED3_MODE: u32 = 0x07000000;

const NVM_CFG_DONE_PORT_0: u32 = 0x040000; /* MNG config cycle done */
const NVM_CFG_DONE_PORT_1: u32 = 0x080000; /* ...for second port */
const NVM_CFG_DONE_PORT_2: u32 = 0x100000; /* ...for third port */
const NVM_CFG_DONE_PORT_3: u32 = 0x200000; /* ...for fourth port */

// EEPROM Commands - SPI
const EEPROM_MAX_RETRY_SPI: u16 = 5000; /* Max wait of 5ms, for RDY signal */
const EEPROM_READ_OPCODE_SPI: u16 = 0x03; /* EEPROM read opcode */
const EEPROM_WRITE_OPCODE_SPI: u16 = 0x02; /* EEPROM write opcode */
const EEPROM_A8_OPCODE_SPI: u16 = 0x08; /* opcode bit-3 = address bit-8 */
const EEPROM_WREN_OPCODE_SPI: u16 = 0x06; /* EEPROM set Write Enable latch */
const EEPROM_WRDI_OPCODE_SPI: u16 = 0x04; /* EEPROM reset Write Enable latch */
const EEPROM_RDSR_OPCODE_SPI: u16 = 0x05; /* EEPROM read Status register */
const EEPROM_WRSR_OPCODE_SPI: u16 = 0x01; /* EEPROM write Status register */
const EEPROM_ERASE4K_OPCODE_SPI: u16 = 0x20; /* EEPROM ERASE 4KB */
const EEPROM_ERASE64K_OPCODE_SPI: u16 = 0xD8; /* EEPROM ERASE 64KB */
const EEPROM_ERASE256_OPCODE_SPI: u16 = 0xDB; /* EEPROM ERASE 256B */

// SPI EEPROM Status Register
const EEPROM_STATUS_RDY_SPI: u16 = 0x01;
const EEPROM_STATUS_WEN_SPI: u16 = 0x02;
const EEPROM_STATUS_BP0_SPI: u16 = 0x04;
const EEPROM_STATUS_BP1_SPI: u16 = 0x08;
const EEPROM_STATUS_WPEN_SPI: u16 = 0x80;

// Number of milliseconds we wait for PHY configuration done after MAC reset
const PHY_CFG_TIMEOUT: u32 = 100;

const fn gg82563_reg(page: u32, reg: u32) -> u32 {
    (page << GG82563_PAGE_SHIFT) | (reg & MAX_PHY_REG_ADDRESS)
}

const fn phy_reg(page: u32, reg: u32) -> u32 {
    (page << PHY_PAGE_SHIFT) | (reg & MAX_PHY_REG_ADDRESS)
}

#[derive(Debug)]
pub enum MediaType {
    Copper,
    Fiber,
    InternalSerdes,
    OEM,
}

#[derive(Debug)]
pub enum PhyType {
    M88,
    Igp,
    Igp2,
    Gg82563,
    Igp3,
    Ife,
    Bm, // phy used in i82574L, ICH10 and some ICH9
    Oem,
    I82577,
    I82578,
    I82579,
    I217,
    I82580,
    Rtl8211,
    Undefined,
}

#[derive(Debug)]
pub struct IgbHw {
    mac_type: MacType,
    initialize_hw_bits_disable: bool,
    eee_enable: bool,
    icp_intel_vendor_idx_port_num: u8,
    swfwhw_semaphore_present: bool,
    asf_firmware_present: bool,
    swfw_sync_present: bool,
    swfw: u16,
    eeprom_semaphore_present: bool,
    phy_reset_disable: bool,
    flash_memory: Option<(BaseAddress, usize)>, // (base address, offset)
    flash_bank_size: Option<usize>,
    flash_base_address: Option<usize>,
    eeprom: EEPROM,
    tbi_compatibility_on: bool,
    tbi_compatibility_en: bool,
    media_type: MediaType,
    sgmii_active: bool,
    sw_flag: isize,
    phy_addr: u32,
    phy_revision: Option<u32>,
    phy_type: PhyType,
    phy_id: u32,
    bus_func: u8,
}

#[derive(Debug, Clone)]
pub enum MacType {
    Em82542Rev2_0 = 0,
    Em82542Rev2_1,
    Em82543,
    Em82544,
    Em82540,
    Em82545,
    Em82545Rev3,
    EmICPxxxx,
    Em82546,
    Em82546Rev3,
    Em82541,
    Em82541Rev2,
    Em82547,
    Em82547Rev2,
    Em82571,
    Em82572,
    Em82573,
    Em82574,
    Em82575,
    Em82576,
    Em82580,
    EmI350,
    EmI210,
    Em80003es2lan,
    EmIch8lan,
    EmIch9lan,
    EmIch10lan,
    EmPchlan,
    EmPch2lan,
    EmPchLpt,
    EmPchSpt,
    EmPchCnp,
    EmPchTgp,
    EmPchAdp,
}

/// Return `(MacType, initialize_hw_bits_disable, eee_enable, icp_intel_vendor_idx_port_num)`.
///
/// https://github.com/openbsd/src/blob/f058c8dbc8e3b2524b639ac291b898c7cc708996/sys/dev/pci/if_em_hw.c#L403
fn get_mac_type(device: u16, info: &PCIeInfo) -> Result<(MacType, bool, bool, u8), IgbDriverErr> {
    use MacType::*;

    let mut initialize_hw_bits_disable = false;
    let mut eee_enable = false;
    let mut icp_intel_vendor_idx_port_num = 0;

    let result = match device {
        E1000_DEV_ID_82542 => match info.get_revision_id() {
            E1000_82542_2_0_REV_ID => Em82542Rev2_0,
            E1000_82542_2_1_REV_ID => Em82542Rev2_1,
            _ => return Err(IgbDriverErr::UnknownRevisionD),
        },
        E1000_DEV_ID_82543GC_FIBER | E1000_DEV_ID_82543GC_COPPER => Em82543,

        E1000_DEV_ID_82544EI_COPPER
        | E1000_DEV_ID_82544EI_FIBER
        | E1000_DEV_ID_82544GC_COPPER
        | E1000_DEV_ID_82544GC_LOM => Em82544,
        E1000_DEV_ID_82540EM
        | E1000_DEV_ID_82540EM_LOM
        | E1000_DEV_ID_82540EP
        | E1000_DEV_ID_82540EP_LOM
        | E1000_DEV_ID_82540EP_LP => Em82540,
        E1000_DEV_ID_82545EM_COPPER | E1000_DEV_ID_82545EM_FIBER => Em82545,
        E1000_DEV_ID_82545GM_COPPER | E1000_DEV_ID_82545GM_FIBER | E1000_DEV_ID_82545GM_SERDES => {
            Em82545Rev3
        }
        E1000_DEV_ID_82546EB_COPPER
        | E1000_DEV_ID_82546EB_FIBER
        | E1000_DEV_ID_82546EB_QUAD_COPPER => Em82546,
        E1000_DEV_ID_82546GB_COPPER
        | E1000_DEV_ID_82546GB_FIBER
        | E1000_DEV_ID_82546GB_SERDES
        | E1000_DEV_ID_82546GB_PCIE
        | E1000_DEV_ID_82546GB_QUAD_COPPER
        | E1000_DEV_ID_82546GB_QUAD_COPPER_KSP3
        | E1000_DEV_ID_82546GB_2 => Em82546Rev3,
        E1000_DEV_ID_82541EI | E1000_DEV_ID_82541EI_MOBILE | E1000_DEV_ID_82541ER_LOM => Em82541,
        E1000_DEV_ID_82541ER
        | E1000_DEV_ID_82541GI
        | E1000_DEV_ID_82541GI_LF
        | E1000_DEV_ID_82541GI_MOBILE => Em82541Rev2,
        E1000_DEV_ID_82547EI | E1000_DEV_ID_82547EI_MOBILE => Em82547,
        E1000_DEV_ID_82547GI => Em82547Rev2,
        E1000_DEV_ID_82571EB_AF
        | E1000_DEV_ID_82571EB_AT
        | E1000_DEV_ID_82571EB_COPPER
        | E1000_DEV_ID_82571EB_FIBER
        | E1000_DEV_ID_82571EB_SERDES
        | E1000_DEV_ID_82571EB_QUAD_COPPER
        | E1000_DEV_ID_82571EB_QUAD_FIBER
        | E1000_DEV_ID_82571EB_QUAD_COPPER_LP
        | E1000_DEV_ID_82571EB_SERDES_DUAL
        | E1000_DEV_ID_82571EB_SERDES_QUAD
        | E1000_DEV_ID_82571PT_QUAD_COPPER => Em82571,
        E1000_DEV_ID_82572EI_COPPER
        | E1000_DEV_ID_82572EI_FIBER
        | E1000_DEV_ID_82572EI_SERDES
        | E1000_DEV_ID_82572EI => Em82572,
        E1000_DEV_ID_82573E
        | E1000_DEV_ID_82573E_IAMT
        | E1000_DEV_ID_82573E_PM
        | E1000_DEV_ID_82573L
        | E1000_DEV_ID_82573L_PL_1
        | E1000_DEV_ID_82573L_PL_2
        | E1000_DEV_ID_82573V_PM => Em82573,
        E1000_DEV_ID_82574L | E1000_DEV_ID_82574LA | E1000_DEV_ID_82583V => Em82574,
        E1000_DEV_ID_82575EB_PT
        | E1000_DEV_ID_82575EB_PF
        | E1000_DEV_ID_82575GB_QP
        | E1000_DEV_ID_82575GB_QP_PM => {
            initialize_hw_bits_disable = true;
            Em82575
        }
        E1000_DEV_ID_82576
        | E1000_DEV_ID_82576_FIBER
        | E1000_DEV_ID_82576_SERDES
        | E1000_DEV_ID_82576_QUAD_COPPER
        | E1000_DEV_ID_82576_QUAD_CU_ET2
        | E1000_DEV_ID_82576_NS
        | E1000_DEV_ID_82576_NS_SERDES
        | E1000_DEV_ID_82576_SERDES_QUAD => {
            initialize_hw_bits_disable = true;
            Em82576
        }
        E1000_DEV_ID_82580_COPPER
        | E1000_DEV_ID_82580_FIBER
        | E1000_DEV_ID_82580_QUAD_FIBER
        | E1000_DEV_ID_82580_SERDES
        | E1000_DEV_ID_82580_SGMII
        | E1000_DEV_ID_82580_COPPER_DUAL
        | E1000_DEV_ID_DH89XXCC_SGMII
        | E1000_DEV_ID_DH89XXCC_SERDES
        | E1000_DEV_ID_DH89XXCC_BACKPLANE
        | E1000_DEV_ID_DH89XXCC_SFP => {
            initialize_hw_bits_disable = true;
            Em82580
        }
        E1000_DEV_ID_I210_COPPER
        | E1000_DEV_ID_I210_COPPER_OEM1
        | E1000_DEV_ID_I210_COPPER_IT
        | E1000_DEV_ID_I210_FIBER
        | E1000_DEV_ID_I210_SERDES
        | E1000_DEV_ID_I210_SGMII
        | E1000_DEV_ID_I210_COPPER_FLASHLESS
        | E1000_DEV_ID_I210_SERDES_FLASHLESS
        | E1000_DEV_ID_I211_COPPER => {
            initialize_hw_bits_disable = true;
            eee_enable = true;
            EmI210
        }
        E1000_DEV_ID_I350_COPPER
        | E1000_DEV_ID_I350_FIBER
        | E1000_DEV_ID_I350_SERDES
        | E1000_DEV_ID_I350_SGMII
        | E1000_DEV_ID_I350_DA4
        | E1000_DEV_ID_I354_BACKPLANE_1GBPS
        | E1000_DEV_ID_I354_SGMII
        | E1000_DEV_ID_I354_BACKPLANE_2_5GBPS => {
            initialize_hw_bits_disable = true;
            eee_enable = true;
            EmI350
        }
        E1000_DEV_ID_80003ES2LAN_COPPER_SPT
        | E1000_DEV_ID_80003ES2LAN_SERDES_SPT
        | E1000_DEV_ID_80003ES2LAN_COPPER_DPT
        | E1000_DEV_ID_80003ES2LAN_SERDES_DPT => Em80003es2lan,
        E1000_DEV_ID_ICH8_IFE
        | E1000_DEV_ID_ICH8_IFE_G
        | E1000_DEV_ID_ICH8_IFE_GT
        | E1000_DEV_ID_ICH8_IGP_AMT
        | E1000_DEV_ID_ICH8_IGP_C
        | E1000_DEV_ID_ICH8_IGP_M
        | E1000_DEV_ID_ICH8_IGP_M_AMT
        | E1000_DEV_ID_ICH8_82567V_3 => EmIch8lan,
        E1000_DEV_ID_ICH9_BM
        | E1000_DEV_ID_ICH9_IFE
        | E1000_DEV_ID_ICH9_IFE_G
        | E1000_DEV_ID_ICH9_IFE_GT
        | E1000_DEV_ID_ICH9_IGP_AMT
        | E1000_DEV_ID_ICH9_IGP_C
        | E1000_DEV_ID_ICH9_IGP_M
        | E1000_DEV_ID_ICH9_IGP_M_AMT
        | E1000_DEV_ID_ICH9_IGP_M_V
        | E1000_DEV_ID_ICH10_R_BM_LF
        | E1000_DEV_ID_ICH10_R_BM_LM
        | E1000_DEV_ID_ICH10_R_BM_V => EmIch9lan,
        E1000_DEV_ID_ICH10_D_BM_LF | E1000_DEV_ID_ICH10_D_BM_LM | E1000_DEV_ID_ICH10_D_BM_V => {
            EmIch10lan
        }
        E1000_DEV_ID_PCH_M_HV_LC
        | E1000_DEV_ID_PCH_M_HV_LM
        | E1000_DEV_ID_PCH_D_HV_DC
        | E1000_DEV_ID_PCH_D_HV_DM => {
            eee_enable = true;
            EmPchlan
        }
        E1000_DEV_ID_PCH2_LV_LM | E1000_DEV_ID_PCH2_LV_V => EmPch2lan,
        E1000_DEV_ID_PCH_LPT_I217_LM
        | E1000_DEV_ID_PCH_LPT_I217_V
        | E1000_DEV_ID_PCH_LPTLP_I218_LM
        | E1000_DEV_ID_PCH_LPTLP_I218_V
        | E1000_DEV_ID_PCH_I218_LM2
        | E1000_DEV_ID_PCH_I218_V2
        | E1000_DEV_ID_PCH_I218_LM3
        | E1000_DEV_ID_PCH_I218_V3 => EmPchLpt,
        E1000_DEV_ID_PCH_SPT_I219_LM
        | E1000_DEV_ID_PCH_SPT_I219_V
        | E1000_DEV_ID_PCH_SPT_I219_LM2
        | E1000_DEV_ID_PCH_SPT_I219_V2
        | E1000_DEV_ID_PCH_LBG_I219_LM3
        | E1000_DEV_ID_PCH_SPT_I219_LM4
        | E1000_DEV_ID_PCH_SPT_I219_V4
        | E1000_DEV_ID_PCH_SPT_I219_LM5
        | E1000_DEV_ID_PCH_SPT_I219_V5
        | E1000_DEV_ID_PCH_CMP_I219_LM12
        | E1000_DEV_ID_PCH_CMP_I219_V12 => EmPchSpt,
        E1000_DEV_ID_PCH_CNP_I219_LM6
        | E1000_DEV_ID_PCH_CNP_I219_V6
        | E1000_DEV_ID_PCH_CNP_I219_LM7
        | E1000_DEV_ID_PCH_CNP_I219_V7
        | E1000_DEV_ID_PCH_ICP_I219_LM8
        | E1000_DEV_ID_PCH_ICP_I219_V8
        | E1000_DEV_ID_PCH_ICP_I219_LM9
        | E1000_DEV_ID_PCH_ICP_I219_V9
        | E1000_DEV_ID_PCH_CMP_I219_LM10
        | E1000_DEV_ID_PCH_CMP_I219_V10
        | E1000_DEV_ID_PCH_CMP_I219_LM11
        | E1000_DEV_ID_PCH_CMP_I219_V11 => EmPchCnp,
        E1000_DEV_ID_PCH_TGP_I219_LM13
        | E1000_DEV_ID_PCH_TGP_I219_V13
        | E1000_DEV_ID_PCH_TGP_I219_LM14
        | E1000_DEV_ID_PCH_TGP_I219_V14
        | E1000_DEV_ID_PCH_TGP_I219_LM15
        | E1000_DEV_ID_PCH_TGP_I219_V15 => EmPchTgp,
        E1000_DEV_ID_PCH_ADP_I219_LM16
        | E1000_DEV_ID_PCH_ADP_I219_V16
        | E1000_DEV_ID_PCH_ADP_I219_LM17
        | E1000_DEV_ID_PCH_ADP_I219_V17
        | E1000_DEV_ID_PCH_MTP_I219_LM18
        | E1000_DEV_ID_PCH_MTP_I219_V18
        | E1000_DEV_ID_PCH_MTP_I219_LM19
        | E1000_DEV_ID_PCH_MTP_I219_V19 => EmPchAdp,
        E1000_DEV_ID_EP80579_LAN_1 => {
            icp_intel_vendor_idx_port_num = 0;
            EmICPxxxx
        }
        E1000_DEV_ID_EP80579_LAN_2 | E1000_DEV_ID_EP80579_LAN_4 => {
            icp_intel_vendor_idx_port_num = 1;
            EmICPxxxx
        }
        E1000_DEV_ID_EP80579_LAN_3 | E1000_DEV_ID_EP80579_LAN_5 => {
            icp_intel_vendor_idx_port_num = 2;
            EmICPxxxx
        }
        E1000_DEV_ID_EP80579_LAN_6 => {
            icp_intel_vendor_idx_port_num = 3;
            EmICPxxxx
        }
        _ => return Err(IgbDriverErr::UnknownDeviceID),
    };

    Ok((
        result,
        initialize_hw_bits_disable,
        eee_enable,
        icp_intel_vendor_idx_port_num,
    ))
}

/// Return (swfwhw_semaphore_present, asf_firmware_present, swfw_sync_present, eeprom_semaphore_present).
fn get_hw_info(mac_type: &MacType) -> (bool, bool, bool, bool) {
    use MacType::*;

    let mut swfwhw_semaphore_present = false;
    let mut asf_firmware_present = false;
    let mut swfw_sync_present = false;
    let mut eeprom_semaphore_present = false;

    match mac_type {
        EmIch8lan | EmIch9lan | EmIch10lan | EmPchlan | EmPch2lan | EmPchLpt | EmPchSpt
        | EmPchCnp | EmPchTgp | EmPchAdp => {
            swfwhw_semaphore_present = true;
            asf_firmware_present = true;
        }
        Em80003es2lan | Em82575 | Em82576 | Em82580 | EmI350 | EmI210 => {
            swfw_sync_present = true;
        }
        Em82571 | Em82572 | Em82573 | Em82574 => {
            eeprom_semaphore_present = true;
        }
        Em82547 | Em82542Rev2_1 | Em82547Rev2 => {
            asf_firmware_present = true;
        }
        _ => (),
    }

    (
        swfwhw_semaphore_present,
        asf_firmware_present,
        swfw_sync_present,
        eeprom_semaphore_present,
    )
}

/// Reject non-PCI Express devices.
///
/// https://github.com/openbsd/src/blob/d88178ae581240e08c6acece5c276298d1ac6c90/sys/dev/pci/if_em_hw.c#L8381
fn check_pci_express(mac_type: &MacType) -> Result<(), IgbDriverErr> {
    use MacType::*;

    match mac_type {
        Em82571 | Em82572 | Em82573 | Em82574 | Em82575 | Em82576 | Em82580 | Em80003es2lan
        | EmI210 | EmI350 | EmIch8lan | EmIch9lan | EmIch10lan | EmPchlan | EmPch2lan
        | EmPchLpt | EmPchSpt | EmPchCnp | EmPchTgp | EmPchAdp => Ok(()),
        _ => Err(IgbDriverErr::NotPciExpress),
    }
}

fn is_ich8(mac_type: &MacType) -> bool {
    use MacType::*;
    matches!(
        mac_type,
        EmIch8lan
            | EmIch9lan
            | EmIch10lan
            | EmPchlan
            | EmPch2lan
            | EmPchLpt
            | EmPchSpt
            | EmPchCnp
            | EmPchTgp
            | EmPchAdp
    )
}

impl IgbHw {
    pub fn new(info: &mut PCIeInfo) -> Result<Self, IgbDriverErr> {
        let (mac_type, initialize_hw_bits_disable, eee_enable, icp_intel_vendor_idx_port_num) =
            get_mac_type(info.get_id(), info)?;

        check_pci_express(&mac_type)?;

        let (
            swfwhw_semaphore_present,
            asf_firmware_present,
            swfw_sync_present,
            eeprom_semaphore_present,
        ) = get_hw_info(&mac_type);

        if matches!(mac_type, MacType::EmPchlan) {
            info.set_revision_id((info.get_id() & 0x0f) as u8);
        }

        // https://github.com/openbsd/src/blob/d88178ae581240e08c6acece5c276298d1ac6c90/sys/dev/pci/if_em.c#L1720-L1740
        let flash_memory = if matches!(mac_type, MacType::EmPchSpt) {
            Some((info.get_bar(0).ok_or(IgbDriverErr::NoBar0)?, 0xe000))
        } else if is_ich8(&mac_type) {
            let bar1 = info.get_bar(1).ok_or(IgbDriverErr::NoBar1)?;
            if matches!(bar1, BaseAddress::MMIO { .. }) {
                Some((bar1, 0))
            } else {
                return Err(IgbDriverErr::Bar1IsNotMMIO);
            }
        } else {
            None
        };

        let (eeprom, flash_base_address, flash_bank_size) =
            EEPROM::new(&mac_type, &flash_memory, info)?;

        let (tbi_compatibility_en, media_type, sgmii_active) = set_media_type(&mac_type, info)?;

        let (bus_func, swfw) = if matches!(
            mac_type,
            MacType::Em80003es2lan
                | MacType::Em82575
                | MacType::Em82576
                | MacType::Em82580
                | MacType::EmI210
                | MacType::EmI350
        ) {
            let reg = read_reg(info, super::STATUS)?;
            let bus_func = (reg & super::STATUS_FUNC_MASK) >> super::STATUS_FUNC_SHIFT;

            let swfw = match bus_func {
                0 => SWFW_PHY0_SM,
                1 => SWFW_PHY1_SM,
                2 => SWFW_PHY2_SM,
                3 => SWFW_PHY3_SM,
                _ => return Err(IgbDriverErr::Phy),
            };

            (bus_func as u8, swfw)
        } else {
            (0, 0)
        };

        let mut hw = Self {
            mac_type,
            initialize_hw_bits_disable,
            eee_enable,
            icp_intel_vendor_idx_port_num,
            swfwhw_semaphore_present,
            asf_firmware_present,
            swfw,
            swfw_sync_present,
            eeprom_semaphore_present,
            phy_reset_disable: false,
            flash_memory,
            flash_base_address,
            flash_bank_size,
            eeprom,
            tbi_compatibility_on: false,
            tbi_compatibility_en,
            media_type,
            sgmii_active,
            sw_flag: 0,
            phy_addr: 0,
            phy_revision: None,
            phy_type: PhyType::Undefined,
            phy_id: 0,
            bus_func,
        };

        // Initialize phy_addr, phy_revision, phy_type, and phy_id
        hw.detect_gig_phy(info)?;

        Ok(hw)
    }

    pub fn get_mac_type(&self) -> MacType {
        self.mac_type.clone()
    }

    /// https://github.com/openbsd/src/blob/f058c8dbc8e3b2524b639ac291b898c7cc708996/sys/dev/pci/if_em_hw.c#L1559
    fn init_hw(info: &PCIeInfo) {
        todo!();
    }

    /// Reset the transmit and receive units; mask and clear all interrupts.
    /// https://github.com/openbsd/src/blob/18bc31b7ebc17ab66d1354464ff2ee3ba31f7750/sys/dev/pci/if_em_hw.c#L925
    pub fn reset_hw(&mut self, info: &PCIeInfo) -> Result<(), IgbDriverErr> {
        use MacType::*;

        let mut bar0 = info.get_bar(0).ok_or(IgbDriverErr::NoBar0)?;

        if matches!(self.mac_type, Em82542Rev2_0) {
            return Err(IgbDriverErr::NotSupported);
        }

        // Prevent the PCI-E bus from sticking if there is no TLP
        // connection on the last TLP read/write transaction when MAC
        // is reset.
        disable_pciex_master(info)?;

        // Set the completion timeout for 82575 chips
        if matches!(self.mac_type, Em82575 | Em82580 | Em82576 | EmI210 | EmI350) {
            set_pciex_completion_timeout(info)?;
        }

        // Clear interrupt mask to stop board from generating interrupts
        bar0.write(super::IMC, !0);

        // Disable the Transmit and Receive units.  Then delay to allow any
        // pending transactions to complete before we hit the MAC with the
        // global reset.
        bar0.write(super::RCTL, 0);
        bar0.write(super::TCTL, super::TCTL_PSP);
        write_flush(info)?;

        // The tbi_compatibility_on Flag must be cleared when Rctl is cleared.
        self.tbi_compatibility_on = false;

        // Delay to allow any outstanding PCI transactions to complete before resetting the device
        awkernel_lib::delay::wait_millisec(10);

        // Must reset the PHY before resetting the MAC
        if matches!(self.mac_type, Em82541 | Em82547) {
            return Err(IgbDriverErr::NotSupported);
        }

        // Must acquire the MDIO ownership before MAC reset. Ownership defaults to firmware after a reset.
        if matches!(self.mac_type, Em82573 | Em82574) {
            let mut extcnf_ctrl = bar0
                .read(super::EXTCNF_CTRL)
                .ok_or(IgbDriverErr::ReadFailure)?;

            extcnf_ctrl |= super::EXTCNF_CTRL_MDIO_SW_OWNERSHIP;

            for _ in 0..10 {
                bar0.write(super::EXTCNF_CTRL, extcnf_ctrl);

                if extcnf_ctrl & super::EXTCNF_CTRL_MDIO_SW_OWNERSHIP != 0 {
                    break;
                } else {
                    extcnf_ctrl |= super::EXTCNF_CTRL_MDIO_SW_OWNERSHIP;
                }

                awkernel_lib::delay::wait_millisec(2);
            }
        }

        // Workaround for ICH8 bit corruption issue in FIFO memory
        if matches!(self.mac_type, EmIch8lan) {
            // Set Tx and Rx buffer allocation to 8k apiece.
            bar0.write(super::PBA, E1000_PBA_8K);

            // Set Packet Buffer Size to 16k.
            bar0.write(super::PBS, E1000_PBS_16K);
        }

        match self.mac_type {
            EmIch8lan | EmIch9lan | EmIch10lan | EmPchlan | EmPch2lan | EmPchLpt | EmPchSpt
            | EmPchCnp | EmPchTgp | EmPchAdp => {
                let mut ctrl = bar0.read(super::CTRL).ok_or(IgbDriverErr::ReadFailure)?;

                if !self.phy_reset_disable && self.check_phy_reset_block(info).is_ok() {
                    // PHY HW reset requires MAC CORE reset at the same
                    // time to make sure the interface between MAC and
                    // the external PHY is reset.
                    ctrl |= super::CTRL_PHY_RST;

                    // Gate automatic PHY configuration by hardware on non-managed 82579
                    if matches!(self.mac_type, EmPch2lan)
                        && bar0.read(super::FWSM).ok_or(IgbDriverErr::ReadFailure)?
                            & super::FWSM_FW_VALID
                            == 0
                    {
                        self.gate_hw_phy_config_ich8lan(info, true)?;
                    }
                };

                self.get_software_flag(info)?;
                bar0.write(super::CTRL, ctrl | super::CTRL_RST);

                // HW reset releases software_flag
                self.sw_flag = 0;
                awkernel_lib::delay::wait_millisec(20);

                // Ungate automatic PHY configuration on non-managed 82579
                if matches!(self.mac_type, EmPch2lan)
                    && !self.phy_reset_disable
                    && bar0.read(super::FWSM).ok_or(IgbDriverErr::ReadFailure)?
                        & super::FWSM_FW_VALID
                        == 0
                {
                    awkernel_lib::delay::wait_millisec(10);
                    self.gate_hw_phy_config_ich8lan(info, false)?;
                }
            }
            _ => {
                let ctrl = bar0.read(super::CTRL).ok_or(IgbDriverErr::ReadFailure)?;
                bar0.write(super::CTRL, ctrl | super::CTRL_RST);
            }
        }

        if self.check_phy_reset_block(info).is_ok() {
            match &self.mac_type {
                EmPchlan => {
                    self.hv_phy_workarounds_ich8lan(info)?;
                }
                EmPch2lan => {
                    self.lv_phy_workarounds_ich8lan(info)?;
                }
                _ => (),
            }
        }

        // TODO
        // https://github.com/openbsd/src/blob/310206ba8923a6e59fdbb6eae66d8488b45fe1d8/sys/dev/pci/if_em_hw.c#L1113

        Ok(())
    }

    /// Probes the expected PHY address for known PHY IDs
    fn detect_gig_phy(&mut self, info: &PCIeInfo) -> Result<(), IgbDriverErr> {
        use MacType::*;

        if self.phy_id != 0 {
            return Ok(());
        }

        // default phy address, most phys reside here, but not all (ICH10)
        if !matches!(self.mac_type, EmICPxxxx) {
            self.phy_addr = 1;
        } else {
            self.phy_addr = 0; // There is a phy at phy_addr 0 on EP80579
        }

        // The 82571 firmware may still be configuring the PHY. In this
        // case, we cannot access the PHY until the configuration is done.
        // So we explicitly set the PHY values.

        if matches!(self.mac_type, Em82571 | Em82572) {
            self.phy_id = IGP01E1000_I_PHY_ID;
            self.phy_type = PhyType::Igp2;
            return Ok(());
        }

        // Some of the fiber cards dont have a phy, so we must exit cleanly here
        if matches!(self.media_type, MediaType::Fiber)
            && matches!(
                self.mac_type,
                Em82542Rev2_0 | Em82542Rev2_1 | Em82543 | Em82573 | Em82574 | Em80003es2lan
            )
        {
            self.phy_type = PhyType::Undefined;
            return Ok(());
        }

        if matches!(
            self.media_type,
            MediaType::InternalSerdes | MediaType::Fiber
        ) && self.mac_type.clone() as u32 >= Em82575 as u32
        {
            self.phy_type = PhyType::Undefined;
            return Ok(());
        }

        if self.mac_type.clone() as u32 <= Em82543 as u32 {
            self.phy_hw_reset(info)?;
        }

        // ESB-2 PHY reads require em_phy_gg82563 to be set because of a
        // workaround that forces PHY page 0 to be set or the reads fail.
        // The rest of the code in this routine uses em_read_phy_reg to read
        // the PHY ID. So for ESB-2 we need to have this set so our reads
        // won't fail.  If the attached PHY is not a em_phy_gg82563, the
        // routines below will figure this out as well.
        if matches!(self.mac_type, Em80003es2lan) {
            self.phy_type = PhyType::Gg82563;
        }

        // Power on SGMII phy if it is disabled
        if matches!(self.mac_type, Em82580 | EmI210 | EmI350) {
            let ctrl_ext = read_reg(info, super::CTRL_EXT)?;
            write_reg(info, super::CTRL_EXT, ctrl_ext & !super::CTRL_EXT_SDP3_DATA)?;
            write_flush(info)?;
            awkernel_lib::delay::wait_millisec(300);
        }

        // Read the PHY ID Registers to identify which PHY is onboard.
        for i in 1..8 {
            self.phy_addr = i;
            if self.match_gig_phy(info).is_ok() {
                return Ok(()); // Found a valid PHY address
            }
        }

        Err(IgbDriverErr::Phy)
    }

    /// Reads and matches the expected PHY address for known PHY IDs
    fn match_gig_phy(&mut self, info: &PCIeInfo) -> Result<(), IgbDriverErr> {
        use MacType::*;

        let phy_id_high = self.read_phy_reg(info, PHY_ID1)?;

        awkernel_lib::delay::wait_microsec(20);

        let phy_id_low = self.read_phy_reg(info, PHY_ID2)?;

        self.phy_id = (phy_id_high as u32) << 16 | (phy_id_low as u32 & PHY_REVISION_MASK);
        self.phy_revision = Some(phy_id_low as u32 & !PHY_REVISION_MASK);

        let mut is_match = false;
        match &self.mac_type {
            Em82543 => {
                if self.phy_id == M88E1000_E_PHY_ID {
                    is_match = true;
                }
            }
            Em82544 => {
                if self.phy_id == M88E1000_I_PHY_ID {
                    is_match = true
                }
            }
            Em82540 | Em82545 | Em82545Rev3 | Em82546 | Em82546Rev3 => {
                if self.phy_id == M88E1011_I_PHY_ID {
                    is_match = true;
                }
            }
            Em82541 | Em82541Rev2 | Em82547 | Em82547Rev2 => {
                if self.phy_id == IGP01E1000_I_PHY_ID {
                    is_match = true;
                }
            }
            Em82573 => {
                if self.phy_id == M88E1111_I_PHY_ID {
                    is_match = true;
                }
            }
            Em82574 => {
                if self.phy_id == BME1000_E_PHY_ID {
                    is_match = true;
                }
            }
            Em82575 | Em82576 => {
                if self.phy_id == M88E1000_E_PHY_ID
                    || self.phy_id == IGP01E1000_I_PHY_ID
                    || self.phy_id == IGP03E1000_E_PHY_ID
                {
                    is_match = true;
                }
            }
            Em82580 | EmI210 | EmI350 => {
                if self.phy_id == I82580_I_PHY_ID
                    || self.phy_id == I210_I_PHY_ID
                    || self.phy_id == I347AT4_E_PHY_ID
                    || self.phy_id == I350_I_PHY_ID
                    || self.phy_id == M88E1111_I_PHY_ID
                    || self.phy_id == M88E1112_E_PHY_ID
                    || self.phy_id == M88E1543_E_PHY_ID
                    || self.phy_id == M88E1512_E_PHY_ID
                {
                    let mut mdic = read_reg(info, super::MDICNFG)?;
                    if mdic & super::MDICNFG_EXT_MDIO != 0 {
                        mdic &= super::MDICNFG_PHY_MASK;
                        self.phy_addr = mdic >> super::MDICNFG_PHY_SHIFT;
                    }
                    is_match = true;
                }
            }
            Em80003es2lan => {
                if self.phy_id == GG82563_E_PHY_ID {
                    is_match = true;
                }
            }
            EmIch8lan | EmIch9lan | EmIch10lan | EmPchlan | EmPch2lan => {
                if self.phy_id == IGP03E1000_E_PHY_ID
                    || self.phy_id == IFE_E_PHY_ID
                    || self.phy_id == IFE_PLUS_E_PHY_ID
                    || self.phy_id == IFE_C_E_PHY_ID
                    || self.phy_id == BME1000_E_PHY_ID
                    || self.phy_id == I82577_E_PHY_ID
                    || self.phy_id == I82578_E_PHY_ID
                    || self.phy_id == I82579_E_PHY_ID
                {
                    is_match = true;
                }
            }
            EmPchLpt | EmPchSpt | EmPchCnp | EmPchTgp | EmPchAdp => {
                if self.phy_id == I217_E_PHY_ID {
                    is_match = true;
                }
            }
            EmICPxxxx => {
                if self.phy_id == M88E1141_E_PHY_ID || self.phy_id == RTL8211_E_PHY_ID {
                    is_match = true;
                }
            }
            _ => {
                return Err(IgbDriverErr::Config);
            }
        }

        self.set_phy_type()?;

        if is_match {
            Ok(())
        } else {
            log::warn!("igb: Invalid PHY ID: {:#x}", self.phy_id);
            Err(IgbDriverErr::Phy)
        }
    }

    /// Set the phy type member in the hw struct.
    fn set_phy_type(&mut self) -> Result<(), IgbDriverErr> {
        use MacType::*;

        match self.phy_id {
            M88E1000_E_PHY_ID | M88E1000_I_PHY_ID | M88E1011_I_PHY_ID | M88E1111_I_PHY_ID
            | M88E1112_E_PHY_ID | M88E1543_E_PHY_ID | M88E1512_E_PHY_ID | I210_I_PHY_ID
            | I347AT4_E_PHY_ID => {
                self.phy_type = PhyType::M88;
            }
            IGP01E1000_I_PHY_ID => {
                if matches!(self.mac_type, Em82541 | Em82541Rev2 | Em82547 | Em82547Rev2) {
                    self.phy_type = PhyType::Igp;
                }
            }
            IGP03E1000_E_PHY_ID | IGP04E1000_E_PHY_ID => {
                self.phy_type = PhyType::Igp3;
            }
            IFE_E_PHY_ID | IFE_PLUS_E_PHY_ID | IFE_C_E_PHY_ID => {
                self.phy_type = PhyType::Ife;
            }
            M88E1141_E_PHY_ID => {
                self.phy_type = PhyType::Oem;
            }
            I82577_E_PHY_ID => {
                self.phy_type = PhyType::I82577;
            }
            I82578_E_PHY_ID => {
                self.phy_type = PhyType::I82578;
            }
            I82579_E_PHY_ID => {
                self.phy_type = PhyType::I82579;
            }
            I217_E_PHY_ID => {
                self.phy_type = PhyType::I217;
            }
            I82580_I_PHY_ID | I350_I_PHY_ID => {
                self.phy_type = PhyType::I82580;
            }
            RTL8211_E_PHY_ID => {
                self.phy_type = PhyType::Rtl8211;
            }
            _ => {
                if self.phy_id == BME1000_E_PHY_ID && self.phy_revision == Some(1) {
                    self.phy_type = PhyType::Bm;
                } else if self.phy_id == GG82563_E_PHY_ID && matches!(self.mac_type, Em80003es2lan)
                {
                    self.phy_type = PhyType::Gg82563;
                } else {
                    // Should never have loaded on this device
                    self.phy_type = PhyType::Undefined;
                    return Err(IgbDriverErr::PhyType);
                }
            }
        }

        Ok(())
    }

    /// Release software semaphore FLAG bit (SWFLAG).
    /// SWFLAG is used to synchronize the access to all shared resource between
    /// SW, FW and HW.
    fn release_software_flag(&mut self, info: &PCIeInfo) -> Result<(), IgbDriverErr> {
        if is_ich8(&self.mac_type) {
            assert!(self.sw_flag > 0);

            self.sw_flag -= 1;
            if self.sw_flag > 0 {
                return Ok(());
            }

            let extcnf_ctrl = read_reg(info, super::EXTCNF_CTRL)?;
            let extcnf_ctrl = extcnf_ctrl & !super::EXTCNF_CTRL_SWFLAG;
            write_reg(info, super::EXTCNF_CTRL, extcnf_ctrl)?;
        }

        Ok(())
    }

    /// Resets the PHY
    fn phy_reset(&mut self, info: &PCIeInfo) -> Result<(), IgbDriverErr> {
        todo!();
    }

    /// Returns the PHY to the power-on reset state
    fn phy_hw_reset(&mut self, info: &PCIeInfo) -> Result<(), IgbDriverErr> {
        use MacType::*;

        self.check_phy_reset_block(info)?;

        if self.mac_type.clone() as u32 >= Em82543 as u32 && !matches!(self.mac_type, EmICPxxxx) {
            self.swfw_sync_mut(info, self.swfw, |hw| {
                // Read the device control register and assert the
                // E1000_CTRL_PHY_RST bit. Then, take it out of reset. For
                // pre-em_82571 hardware, we delay for 10ms between the
                // assert and deassert.  For em_82571 hardware and later, we
                // instead delay for 50us between and 10ms after the
                // deassertion.
                let ctrl = read_reg(info, super::CTRL)?;
                write_reg(info, super::CTRL, ctrl | super::CTRL_PHY_RST)?;
                write_flush(info)?;

                if (hw.mac_type.clone() as u32) < Em82571 as u32 {
                    awkernel_lib::delay::wait_millisec(10);
                } else {
                    awkernel_lib::delay::wait_microsec(100);
                }

                write_reg(info, super::CTRL, ctrl)?;
                write_flush(info)?;

                if (hw.mac_type.clone() as u32) >= Em82571 as u32 {
                    awkernel_lib::delay::wait_millisec(10);
                }

                // the M88E1141_E_PHY_ID might need reset here, but nothing
                // proves it

                Ok(())
            })?;
        } else {
            // Read the Extended Device Control Register, assert the
            // PHY_RESET_DIR bit to put the PHY into reset. Then, take it
            // out of reset.
            let ctrl_ext = read_reg(info, super::CTRL_EXT)?;
            let ctrl_ext = ctrl_ext | super::CTRL_EXT_SDP4_DIR;
            let ctrl_ext = ctrl_ext & !super::CTRL_EXT_SDP4_DATA;

            write_reg(info, super::CTRL_EXT, ctrl_ext)?;
            write_flush(info)?;

            awkernel_lib::delay::wait_millisec(10);

            let ctrl_ext = ctrl_ext | super::CTRL_EXT_SDP4_DATA;

            write_reg(info, super::CTRL_EXT, ctrl_ext)?;
            write_flush(info)?;
        }

        awkernel_lib::delay::wait_microsec(50);

        if matches!(self.mac_type, Em82541 | Em82547) {
            // Configure activity LED after PHY reset
            let led_ctrl = read_reg(info, LEDCTL)?;
            let led_ctrl = led_ctrl & IGP_ACTIVITY_LED_MASK;
            let led_ctrl = led_ctrl | IGP_ACTIVITY_LED_ENABLE | IGP_LED3_MODE;
            write_reg(info, LEDCTL, led_ctrl)?;
        }

        // Wait for FW to finish PHY configuration.
        self.get_phy_cfg_done(info)?;

        self.release_software_semaphore(info)?;

        if matches!(self.mac_type, EmIch8lan) && matches!(self.phy_type, PhyType::Igp3) {
            self.init_lcd_from_nvm(info)?;
        }

        Ok(())
    }

    /// This function initializes the PHY from the NVM on ICH8 platforms. This
    /// is needed due to an issue where the NVM configuration is not properly
    /// autoloaded after power transitions. Therefore, after each PHY reset, we
    /// will load the configuration data out of the NVM manually.
    fn init_lcd_from_nvm(&mut self, info: &PCIeInfo) -> Result<(), IgbDriverErr> {
        use MacType::*;

        if !matches!(self.phy_type, PhyType::Igp3) {
            return Ok(());
        }

        // Check if SW needs configure the PHY
        let sw_cfg_mask = if info.id == E1000_DEV_ID_ICH8_IGP_M_AMT
            || info.id == E1000_DEV_ID_ICH8_IGP_M
            || matches!(
                self.mac_type,
                EmPchlan | EmPch2lan | EmPchLpt | EmPchSpt | EmPchCnp | EmPchTgp | EmPchAdp
            ) {
            super::FEXTNVM_SW_CONFIG_ICH8M
        } else {
            super::FEXTNVM_SW_CONFIG
        };

        let reg_data = read_reg(info, super::FEXTNVM)?;
        if reg_data & sw_cfg_mask == 0 {
            return Ok(());
        }

        // Wait for basic configuration completes before proceeding
        for _ in 0..50 {
            let reg_data = read_reg(info, super::STATUS)?;
            awkernel_lib::delay::wait_microsec(100);
            if reg_data & super::STATUS_LAN_INIT_DONE != 0 {
                break;
            }
        }

        // Clear the Init Done bit for the next init event
        let reg_data = read_reg(info, super::STATUS)?;
        let reg_data = reg_data & !super::STATUS_LAN_INIT_DONE;
        write_reg(info, super::STATUS, reg_data)?;

        // Make sure HW does not configure LCD from PHY extended
        // configuration before SW configuration
        let reg_data = read_reg(info, super::EXTCNF_CTRL)?;
        if reg_data & super::EXTCNF_CTRL_LCD_WRITE_ENABLE == 0 {
            let reg_data = read_reg(info, super::EXTCNF_SIZE)?;
            let cnf_size = reg_data & super::EXTCNF_SIZE_EXT_PCIE_LENGTH;
            let cnf_size = cnf_size >> 16;
            if cnf_size != 0 {
                let reg_data = read_reg(info, super::EXTCNF_CTRL)?;
                let cnf_base_addr = reg_data & super::EXTCNF_CTRL_EXT_CNF_POINTER;
                // cnf_base_addr is in DWORD
                let cnf_base_addr = cnf_base_addr >> 16;

                // Configure LCD from extended configuration region.
                self.init_lcd_from_nvm_config_region(info, cnf_base_addr, cnf_size)?;
            }
        }

        Ok(())
    }

    fn init_lcd_from_nvm_config_region(
        &mut self,
        info: &PCIeInfo,
        cnf_base_addr: u32,
        cnf_size: u32,
    ) -> Result<(), IgbDriverErr> {
        // cnf_base_addr is in DWORD
        let word_addr = cnf_base_addr << 1;

        // cnf_size is returned in size of dwords
        for i in 0..cnf_size {
            let mut reg_data = [0];
            let mut reg_addr = [0];

            self.read_eeprom(info, word_addr + i * 2, &mut reg_data)?;
            self.read_eeprom(info, word_addr + i * 2 + 1, &mut reg_addr)?;

            self.get_software_flag(info)?;
            self.write_phy_reg(info, reg_addr[0] as u32, reg_data[0])?;
            self.release_software_flag(info)?;
        }

        Ok(())
    }

    /// Reads a 16 bit word from the EEPROM.
    fn read_eeprom(
        &mut self,
        info: &PCIeInfo,
        offset: u32,
        data: &mut [u16],
    ) -> Result<(), IgbDriverErr> {
        // A check for invalid values:  offset too large, too many words, and
        // not enough words.
        if offset >= self.eeprom.word_size as u32
            || data.len() > (self.eeprom.word_size as u32 - offset) as usize
            || data.is_empty()
        {
            return Err(IgbDriverErr::EEPROM);
        }

        if self.eeprom.use_eerd {
            return self.read_eeprom_eerd(info, offset, data);
        }

        if matches!(self.eeprom.eeprom_type, EEPROMType::Ich8) {
            return self.read_eeprom_ich8(info, offset, data);
        }

        if matches!(self.eeprom.eeprom_type, EEPROMType::Invm) {
            return self.read_invm_i210(info, offset, data);
        }

        // EEPROM's that don't use EERD to read require us to bit-bang the
        // SPI directly. In this case, we need to acquire the EEPROM so that
        // FW or other port software does not interrupt.
        assert!(
            is_onboard_nvm_eeprom(&self.mac_type, info)?
                && get_flash_presence_i210(&self.mac_type, info)?
                && !self.eeprom.use_eerd
        );

        self.acquire_eeprom(info, |hw| {
            // Set up the SPI or Microwire EEPROM for bit-bang reading.  We have
            // acquired the EEPROM at this point, so any returns should release it
            match &hw.eeprom.eeprom_type {
                EEPROMType::SPI => {
                    todo!("SPI");
                }
                EEPROMType::Microwire => {
                    todo!("Microwire");
                }
                _ => Err(IgbDriverErr::EEPROM),
            }
        })
    }

    //     int32_t
    // em_read_eeprom(struct em_hw *hw, uint16_t offset, uint16_t words,
    //     uint16_t *data)
    // {
    // 	struct em_eeprom_info *eeprom = &hw->eeprom;
    // 	uint32_t i = 0;
    // 	DEBUGFUNC("em_read_eeprom");

    // 	/* If eeprom is not yet detected, do so now */
    // 	if (eeprom->word_size == 0)
    // 		em_init_eeprom_params(hw);
    // 	/*
    // 	 * A check for invalid values:  offset too large, too many words, and
    // 	 * not enough words.
    // 	 */
    // 	if ((offset >= eeprom->word_size) ||
    // 	    (words > eeprom->word_size - offset) ||
    // 	    (words == 0)) {
    // 		DEBUGOUT2("\"words\" parameter out of bounds. Words = %d,"
    // 		    " size = %d\n", offset, eeprom->word_size);
    // 		return -E1000_ERR_EEPROM;
    // 	}
    // 	/*
    // 	 * EEPROM's that don't use EERD to read require us to bit-bang the
    // 	 * SPI directly. In this case, we need to acquire the EEPROM so that
    // 	 * FW or other port software does not interrupt.
    // 	 */
    // 	if (em_is_onboard_nvm_eeprom(hw) == TRUE &&
    // 	    em_get_flash_presence_i210(hw) == TRUE &&
    // 	    hw->eeprom.use_eerd == FALSE) {
    // 		/* Prepare the EEPROM for bit-bang reading */
    // 		if (em_acquire_eeprom(hw) != E1000_SUCCESS)
    // 			return -E1000_ERR_EEPROM;
    // 	}
    // 	/* Eerd register EEPROM access requires no eeprom acquire/release */
    // 	if (eeprom->use_eerd == TRUE)
    // 		return em_read_eeprom_eerd(hw, offset, words, data);

    // 	/* ICH EEPROM access is done via the ICH flash controller */
    // 	if (eeprom->type == em_eeprom_ich8)
    // 		return em_read_eeprom_ich8(hw, offset, words, data);

    // 	/* Some i210/i211 have a special OTP chip */
    // 	if (eeprom->type == em_eeprom_invm)
    // 		return em_read_invm_i210(hw, offset, words, data);

    // 	/*
    // 	 * Set up the SPI or Microwire EEPROM for bit-bang reading.  We have
    // 	 * acquired the EEPROM at this point, so any returns should release it
    // 	 */
    // 	if (eeprom->type == em_eeprom_spi) {
    // 		uint16_t word_in;
    // 		uint8_t  read_opcode = EEPROM_READ_OPCODE_SPI;
    // 		if (em_spi_eeprom_ready(hw)) {
    // 			em_release_eeprom(hw);
    // 			return -E1000_ERR_EEPROM;
    // 		}
    // 		em_standby_eeprom(hw);
    // 		/*
    // 		 * Some SPI eeproms use the 8th address bit embedded in the
    // 		 * opcode
    // 		 */
    // 		if ((eeprom->address_bits == 8) && (offset >= 128))
    // 			read_opcode |= EEPROM_A8_OPCODE_SPI;

    // 		/* Send the READ command (opcode + addr)  */
    // 		em_shift_out_ee_bits(hw, read_opcode, eeprom->opcode_bits);
    // 		em_shift_out_ee_bits(hw, (uint16_t) (offset * 2),
    // 		    eeprom->address_bits);
    // 		/*
    // 		 * Read the data.  The address of the eeprom internally
    // 		 * increments with each byte (spi) being read, saving on the
    // 		 * overhead of eeprom setup and tear-down.  The address
    // 		 * counter will roll over if reading beyond the size of the
    // 		 * eeprom, thus allowing the entire memory to be read
    // 		 * starting from any offset.
    // 		 */
    // 		for (i = 0; i < words; i++) {
    // 			word_in = em_shift_in_ee_bits(hw, 16);
    // 			data[i] = (word_in >> 8) | (word_in << 8);
    // 		}
    // 	} else if (eeprom->type == em_eeprom_microwire) {
    // 		for (i = 0; i < words; i++) {
    // 			/* Send the READ command (opcode + addr)  */
    // 			em_shift_out_ee_bits(hw, EEPROM_READ_OPCODE_MICROWIRE,
    // 			    eeprom->opcode_bits);
    // 			em_shift_out_ee_bits(hw, (uint16_t) (offset + i),
    // 			    eeprom->address_bits);
    // 			/*
    // 			 * Read the data.  For microwire, each word requires
    // 			 * the overhead of eeprom setup and tear-down.
    // 			 */
    // 			data[i] = em_shift_in_ee_bits(hw, 16);
    // 			em_standby_eeprom(hw);
    // 		}
    // 	}
    // 	/* End this read operation */
    // 	em_release_eeprom(hw);

    // 	return E1000_SUCCESS;
    // }

    fn read_eeprom_eerd(
        &mut self,
        info: &PCIeInfo,
        offset: u32,
        data: &mut [u16],
    ) -> Result<(), IgbDriverErr> {
        todo!();
    }

    fn read_eeprom_ich8(
        &mut self,
        info: &PCIeInfo,
        offset: u32,
        data: &mut [u16],
    ) -> Result<(), IgbDriverErr> {
        todo!();
    }

    fn read_invm_i210(
        &mut self,
        info: &PCIeInfo,
        offset: u32,
        data: &mut [u16],
    ) -> Result<(), IgbDriverErr> {
        todo!();
    }

    /// Reads a 16 bit word from the EEPROM.
    fn spi_eeprom_ready(&mut self, info: &PCIeInfo) -> Result<(), IgbDriverErr> {
        // Read "Status Register" repeatedly until the LSB is cleared.  The
        // EEPROM will signal that the command has been completed by clearing
        // bit 0 of the internal status register.  If it's not cleared within
        // 5 milliseconds, then error out.
        let mut retry_count = 0;
        loop {
            self.shift_out_ee_bits(info, EEPROM_RDSR_OPCODE_SPI, self.eeprom.opcode_bits)?;
            let spi_stat_reg = self.shift_in_ee_bits(info, 8)?;
            if spi_stat_reg & EEPROM_STATUS_RDY_SPI == 0 {
                break;
            }

            awkernel_lib::delay::wait_microsec(5);
            retry_count += 5;

            self.standby_eeprom(info)?;

            if retry_count >= EEPROM_MAX_RETRY_SPI {
                return Err(IgbDriverErr::EEPROM);
            }
        }

        // ATMEL SPI write time could vary from 0-20mSec on 3.3V devices (and
        // only 0-5mSec on 5V devices)

        if retry_count >= EEPROM_MAX_RETRY_SPI {
            log::warn!("igb: SPI EEPROM Status error");
            return Err(IgbDriverErr::EEPROM);
        }

        Ok(())
    }

    /// Returns EEPROM to a "standby" state
    fn standby_eeprom(&mut self, info: &PCIeInfo) -> Result<(), IgbDriverErr> {
        let mut eecd = read_reg(info, super::EECD)?;

        match self.eeprom.eeprom_type {
            EEPROMType::Microwire => {
                eecd &= !(E1000_EECD_CS | E1000_EECD_SK);
                write_reg(info, super::EECD, eecd)?;
                write_flush(info)?;
                awkernel_lib::delay::wait_microsec(self.eeprom.delay_usec as u64);

                // Clock high
                eecd |= E1000_EECD_SK;
                write_reg(info, super::EECD, eecd)?;
                write_flush(info)?;
                awkernel_lib::delay::wait_microsec(self.eeprom.delay_usec as u64);

                // Select EEPROM
                eecd |= E1000_EECD_CS;
                write_reg(info, super::EECD, eecd)?;
                write_flush(info)?;
                awkernel_lib::delay::wait_microsec(self.eeprom.delay_usec as u64);

                // Clock low
                eecd &= !E1000_EECD_SK;
                write_reg(info, super::EECD, eecd)?;
                write_flush(info)?;
                awkernel_lib::delay::wait_microsec(self.eeprom.delay_usec as u64);

                Ok(())
            }
            EEPROMType::SPI => {
                // Toggle CS to flush commands
                eecd |= E1000_EECD_CS;
                write_reg(info, super::EECD, eecd)?;
                write_flush(info)?;
                awkernel_lib::delay::wait_microsec(self.eeprom.delay_usec as u64);

                eecd &= !E1000_EECD_CS;
                write_reg(info, super::EECD, eecd)?;
                write_flush(info)?;
                awkernel_lib::delay::wait_microsec(self.eeprom.delay_usec as u64);

                Ok(())
            }
            _ => Err(IgbDriverErr::EEPROM),
        }
    }

    /// Shift data bits out to the EEPROM.
    fn shift_out_ee_bits(
        &mut self,
        info: &PCIeInfo,
        data: u16,
        count: u16,
    ) -> Result<(), IgbDriverErr> {
        // We need to shift "count" bits out to the EEPROM. So, value in the
        // "data" parameter will be shifted out to the EEPROM one bit at a
        // time. In order to do this, "data" must be broken down into bits.
        let mut mask = 1 << (count - 1);
        let mut eecd = read_reg(info, super::EECD)?;
        match self.eeprom.eeprom_type {
            EEPROMType::Microwire => {
                eecd &= !E1000_EECD_DO;
            }
            EEPROMType::SPI => {
                eecd |= E1000_EECD_DO;
            }
            _ => (),
        }

        loop {
            // A "1" is shifted out to the EEPROM by setting bit "DI" to
            // a "1", and then raising and then lowering the clock (the
            // SK bit controls the clock input to the EEPROM).  A "0" is
            // shifted out to the EEPROM by setting "DI" to "0" and then
            // raising and then lowering the clock.
            eecd &= !E1000_EECD_DI;

            if data & mask != 0 {
                eecd |= E1000_EECD_DI;
            }

            write_reg(info, super::EECD, eecd)?;
            write_flush(info)?;

            awkernel_lib::delay::wait_microsec(self.eeprom.delay_usec as u64);

            self.raise_ee_clk(info, &mut eecd)?;
            self.lower_ee_clk(info, &mut eecd)?;

            mask >>= 1;

            if mask == 0 {
                break;
            }
        }

        // We leave the "DI" bit set to "0" when we leave this routine.
        eecd &= !E1000_EECD_DI;
        write_reg(info, super::EECD, eecd)?;

        todo!();
    }

    /// Shift data bits in from the EEPROM
    fn shift_in_ee_bits(&mut self, info: &PCIeInfo, count: u16) -> Result<u16, IgbDriverErr> {
        // In order to read a register from the EEPROM, we need to shift
        // 'count' bits in from the EEPROM. Bits are "shifted in" by raising
        // the clock input to the EEPROM (setting the SK bit), and then
        // reading the value of the "DO" bit.  During this "shifting in"
        // process the "DI" bit should always be clear.

        let eecd = read_reg(info, super::EECD)?;
        let mut eecd = eecd & !(E1000_EECD_DO | E1000_EECD_DI);

        let mut data = 0;
        for _ in 0..count {
            data <<= 1;
            self.raise_ee_clk(info, &mut eecd)?;

            eecd = read_reg(info, super::EECD)?;
            eecd &= !(E1000_EECD_DI);

            if eecd & E1000_EECD_DO != 0 {
                data |= 1;
            }

            self.lower_ee_clk(info, &mut eecd)?;
        }

        Ok(data)
    }

    /// Lowers the EEPROM's clock input.
    fn lower_ee_clk(&mut self, info: &PCIeInfo, eecd: &mut u32) -> Result<(), IgbDriverErr> {
        // Lower the clock input to the EEPROM (by clearing the SK bit), and
        // then wait 50 microseconds.
        *eecd &= !E1000_EECD_SK;
        write_reg(info, super::EECD, *eecd)?;
        write_flush(info)?;
        awkernel_lib::delay::wait_microsec(self.eeprom.delay_usec as u64);

        Ok(())
    }

    /// Raises the EEPROM's clock input.
    fn raise_ee_clk(&mut self, info: &PCIeInfo, eecd: &mut u32) -> Result<(), IgbDriverErr> {
        // Raise the clock input to the EEPROM (by setting the SK bit), and
        // then wait <delay> microseconds.
        *eecd |= E1000_EECD_SK;
        write_reg(info, super::EECD, *eecd)?;
        write_flush(info)?;
        awkernel_lib::delay::wait_microsec(self.eeprom.delay_usec as u64);

        Ok(())
    }

    fn acquire_eeprom<T, F>(&mut self, info: &PCIeInfo, f: F) -> Result<T, IgbDriverErr>
    where
        F: FnOnce(&mut Self) -> Result<T, IgbDriverErr>,
    {
        use MacType::*;

        self.swfw_sync_mut(info, SWFW_EEP_SM, move |hw| {
            let eecd = read_reg(info, super::EECD)?;

            // !!(!A && !B) == !(A || B)

            if !matches!(hw.mac_type, Em82573 | Em82574) {
                // Request EEPROM Access
                if hw.mac_type.clone() as u32 > Em82544 as u32 {
                    write_reg(info, super::EECD, eecd | E1000_EECD_REQ)?;
                    let mut eecd = read_reg(info, super::EECD)?;
                    let mut i = 0;

                    while eecd & E1000_EECD_GNT == 0 && i < E1000_EEPROM_GRANT_ATTEMPTS {
                        i += 1;
                        awkernel_lib::delay::wait_microsec(5);
                        eecd = read_reg(info, super::EECD)?;
                    }

                    if eecd & E1000_EECD_GNT == 0 {
                        write_reg(info, super::EECD, eecd & !E1000_EECD_REQ)?;
                        log::warn!("igb: Could not acquire EEPROM grant");
                        return Err(IgbDriverErr::EEPROM);
                    }
                }
            }

            // Setup EEPROM for Read/Write
            match hw.eeprom.eeprom_type {
                EEPROMType::Microwire => {
                    let eecd = read_reg(info, super::EECD)?;
                    let eecd = eecd & !(E1000_EECD_DI | E1000_EECD_SK);
                    // Clear SK and DI
                    write_reg(info, super::EECD, eecd)?;

                    // Set CS
                    let eecd = eecd | E1000_EECD_CS;
                    write_reg(info, super::EECD, eecd)?;
                }
                EEPROMType::SPI => {
                    // Clear SK and CS
                    let eecd = read_reg(info, super::EECD)?;
                    let eecd = eecd & !(E1000_EECD_CS | E1000_EECD_SK);
                    write_reg(info, super::EECD, eecd)?;
                    awkernel_lib::delay::wait_microsec(1);
                }
                _ => (),
            }

            let result = f(hw);

            // release eeprom
            let eecd = read_reg(info, super::EECD)?;

            match hw.eeprom.eeprom_type {
                EEPROMType::SPI => {
                    let eecd = eecd | E1000_EECD_CS; // Pull CS high
                    let eecd = eecd & !E1000_EECD_SK; // Lower SCK
                    write_reg(info, super::EECD, eecd)?;
                    awkernel_lib::delay::wait_microsec(hw.eeprom.delay_usec as u64);
                }
                EEPROMType::Microwire => {
                    // cleanup eeprom
                    // CS on Microwire is active-high
                    let eecd = eecd & !(E1000_EECD_CS | E1000_EECD_DI);
                    write_reg(info, super::EECD, eecd)?;

                    // Rising edge of clock
                    let eecd = eecd | E1000_EECD_SK;
                    write_reg(info, super::EECD, eecd)?;
                    write_flush(info)?;
                    awkernel_lib::delay::wait_microsec(hw.eeprom.delay_usec as u64);

                    // Falling edge of clock
                    let eecd = eecd & !E1000_EECD_SK;
                    write_reg(info, super::EECD, eecd)?;
                    write_flush(info)?;
                    awkernel_lib::delay::wait_microsec(hw.eeprom.delay_usec as u64);
                }
                _ => (),
            }

            // Stop requesting EEPROM access
            if hw.mac_type.clone() as u32 > Em82544 as u32 {
                let eecd = read_reg(info, super::EECD)?;
                let eecd = eecd & !E1000_EECD_REQ;
                write_reg(info, super::EECD, eecd)?;
            }

            result
        })
    }

    /// Checks if the PHY configuration is done
    fn get_phy_cfg_done(&self, info: &PCIeInfo) -> Result<(), IgbDriverErr> {
        use MacType::*;

        let cfg_mask = if matches!(
            self.mac_type,
            Em80003es2lan | Em82575 | Em82576 | Em82580 | EmI350
        ) {
            let cfg_mask = match self.bus_func {
                1 => NVM_CFG_DONE_PORT_1,
                2 => NVM_CFG_DONE_PORT_2,
                3 => NVM_CFG_DONE_PORT_3,
                _ => NVM_CFG_DONE_PORT_0,
            };
            Some(cfg_mask)
        } else if matches!(self.mac_type, Em82571 | Em82572) {
            Some(NVM_CFG_DONE_PORT_0)
        } else {
            None
        };

        if let Some(cfg_mask) = cfg_mask {
            let mut timeout = PHY_CFG_TIMEOUT;

            while timeout > 0 {
                if read_reg(info, super::EEMNGCTL)? & cfg_mask != 0 {
                    break;
                } else {
                    awkernel_lib::delay::wait_millisec(1);
                }

                timeout -= 1;
            }

            if timeout == 0 {
                log::warn!("igb: MNG configuration cycle has not completed.");
            }
        } else {
            awkernel_lib::delay::wait_millisec(10);
        }

        Ok(())
    }

    /// A series of Phy workarounds to be done after every PHY reset.
    fn hv_phy_workarounds_ich8lan(&mut self, info: &PCIeInfo) -> Result<(), IgbDriverErr> {
        if !matches!(self.mac_type, MacType::EmPchlan) {
            return Ok(());
        }

        // Set MDIO slow mode before any other MDIO access
        if matches!(self.phy_type, PhyType::I82577 | PhyType::I82578) {
            self.set_mdio_slow_mode_hv(info)?;
        }

        // Hanksville M Phy init for IEEE.
        if info.revision_id == 2
            && matches!(self.phy_type, PhyType::I82577)
            && self.phy_revision == Some(2)
            || self.phy_revision == Some(3)
        {
            self.write_phy_reg(info, 0x10, 0x8823)?;
            self.write_phy_reg(info, 0x11, 0x0018)?;
            self.write_phy_reg(info, 0x10, 0x8824)?;
            self.write_phy_reg(info, 0x11, 0x0016)?;
            self.write_phy_reg(info, 0x10, 0x8825)?;
            self.write_phy_reg(info, 0x11, 0x001A)?;
            self.write_phy_reg(info, 0x10, 0x888C)?;
            self.write_phy_reg(info, 0x11, 0x0007)?;
            self.write_phy_reg(info, 0x10, 0x888D)?;
            self.write_phy_reg(info, 0x11, 0x0007)?;
            self.write_phy_reg(info, 0x10, 0x888E)?;
            self.write_phy_reg(info, 0x11, 0x0007)?;
            self.write_phy_reg(info, 0x10, 0x8827)?;
            self.write_phy_reg(info, 0x11, 0x0001)?;
            self.write_phy_reg(info, 0x10, 0x8835)?;
            self.write_phy_reg(info, 0x11, 0x0001)?;
            self.write_phy_reg(info, 0x10, 0x8834)?;
            self.write_phy_reg(info, 0x11, 0x0001)?;
            self.write_phy_reg(info, 0x10, 0x8833)?;
            self.write_phy_reg(info, 0x11, 0x0002)?;
        }

        if (matches!(self.phy_type, PhyType::I82577)
            && (self.phy_revision == Some(1) || self.phy_revision == Some(2)))
            || (matches!(self.phy_type, PhyType::I82578) && self.phy_revision == Some(1))
        {
            // Disable generation of early preamble
            self.write_phy_reg(info, phy_reg(769, 25), 0x4431)?;

            // Preamble tuning for SSC
            self.write_phy_reg(info, phy_reg(770, 16), 0xA204)?;
        }

        if matches!(self.phy_type, PhyType::I82578) {
            // Return registers to default by doing a soft reset then
            // writing 0x3140 to the control register.
            if self.phy_revision < Some(2) {
                self.phy_reset(info)?;
                self.write_phy_reg(info, PHY_CTRL, 0x3140)?;
            }
        }

        if info.revision_id == 2
            && matches!(self.phy_type, PhyType::I82577)
            && (self.phy_revision == Some(2) || self.phy_revision == Some(3))
        {
            // Workaround for OEM (GbE) not operating after reset -
            // restart AN (twice)
            self.write_phy_reg(info, phy_reg(0, 25), 0x0400)?;
            self.write_phy_reg(info, phy_reg(0, 25), 0x0400)?;
        }

        let swfw = SWFW_PHY0_SM;

        // select page 0
        self.swfw_sync_mut(info, swfw, move |hw| {
            hw.phy_addr = 1;
            hw.write_phy_reg(info, IGP01E1000_PHY_PAGE_SELECT, 0)?;
            Ok(())
        })?;

        // Workaround for link disconnects on a busy hub in half duplex
        let phy_data = self.read_phy_reg(info, phy_reg(BM_PORT_CTRL_PAGE, 17))?;
        self.write_phy_reg(info, phy_reg(BM_PORT_CTRL_PAGE, 17), phy_data & 0x00FF)?;

        Ok(())
    }

    /// em_lv_phy_workarounds_ich8lan - A series of Phy workarounds to be
    /// done after every PHY reset.
    fn lv_phy_workarounds_ich8lan(&mut self, info: &PCIeInfo) -> Result<(), IgbDriverErr> {
        if !matches!(self.mac_type, MacType::EmPch2lan) {
            return Ok(());
        }

        // Set MDIO slow mode before any other MDIO access
        self.set_mdio_slow_mode_hv(info)?;

        let swfw = SWFW_PHY0_SM;
        self.swfw_sync_mut(info, swfw, |hw| {
            hw.write_phy_reg(info, I82579_EMI_ADDR, I82579_MSE_THRESHOLD)?;

            // set MSE higher to enable link to stay up when noise is high
            hw.write_phy_reg(info, I82579_EMI_DATA, 0x0034)?;

            hw.write_phy_reg(info, I82579_EMI_ADDR, I82579_MSE_LINK_DOWN)?;

            // drop link after 5 times MSE threshold was reached
            hw.write_phy_reg(info, I82579_EMI_DATA, 0x0005)?;

            Ok(())
        })
    }

    /// Set slow MDIO access mode
    fn set_mdio_slow_mode_hv(&mut self, info: &PCIeInfo) -> Result<(), IgbDriverErr> {
        let data = self.read_phy_reg(info, HV_KMRN_MODE_CTRL)?;
        self.write_phy_reg(info, HV_KMRN_MODE_CTRL, data)?;
        Ok(())
    }

    /// Writes a value to a PHY register
    fn write_phy_reg(
        &mut self,
        info: &PCIeInfo,
        reg_addr: u32,
        phy_data: u16,
    ) -> Result<(), IgbDriverErr> {
        use MacType::*;

        if matches!(
            self.mac_type,
            EmPchlan | EmPch2lan | EmPchLpt | EmPchSpt | EmPchCnp | EmPchTgp | EmPchAdp
        ) {
            return self.access_phy_reg_hv_write(info, reg_addr, phy_data);
        }

        self.swfw_sync_mut(info, self.swfw, |hw| {
            if matches!(hw.phy_type, PhyType::Igp | PhyType::Igp2 | PhyType::Igp3)
                && (reg_addr > MAX_PHY_MULTI_PAGE_REG)
            {
                hw.write_phy_reg_ex(info, IGP01E1000_PHY_PAGE_SELECT, reg_addr as u16)?;
            } else if matches!(hw.phy_type, PhyType::Gg82563)
                && ((reg_addr & MAX_PHY_REG_ADDRESS) > MAX_PHY_MULTI_PAGE_REG
                    || matches!(hw.mac_type, Em80003es2lan))
            {
                // Select Configuration Page
                if (reg_addr & MAX_PHY_REG_ADDRESS) < GG82563_MIN_ALT_REG {
                    hw.write_phy_reg_ex(
                        info,
                        GG82563_PHY_PAGE_SELECT,
                        (reg_addr >> GG82563_PAGE_SHIFT) as u16,
                    )?;
                } else {
                    // Use Alternative Page Select register to access registers 30 and 31
                    hw.write_phy_reg_ex(
                        info,
                        GG82563_PHY_PAGE_SELECT_ALT,
                        (reg_addr >> GG82563_PAGE_SHIFT) as u16,
                    )?;
                }
            } else if matches!(hw.phy_type, PhyType::Bm)
                && hw.phy_revision == Some(1)
                && reg_addr > MAX_PHY_MULTI_PAGE_REG
            {
                hw.write_phy_reg_ex(
                    info,
                    BM_PHY_PAGE_SELECT,
                    (reg_addr >> PHY_PAGE_SHIFT) as u16,
                )?;
            }

            hw.write_phy_reg_ex(info, MAX_PHY_REG_ADDRESS & reg_addr, phy_data)?;

            Ok(())
        })
    }

    /// Reads the value from a PHY register, if the value is on a specific non zero
    /// page, sets the page first.
    fn read_phy_reg(&mut self, info: &PCIeInfo, reg_addr: u32) -> Result<u16, IgbDriverErr> {
        use MacType::*;

        if matches!(
            self.mac_type,
            EmPchlan | EmPch2lan | EmPchLpt | EmPchSpt | EmPchCnp | EmPchTgp | EmPchAdp
        ) {
            return self.access_phy_reg_hv_read(info, reg_addr);
        }

        let swfw = if matches!(self.mac_type, Em80003es2lan | Em82575 | Em82576)
            && read_reg(info, super::STATUS)? & super::STATUS_FUNC_1 != 0
        {
            SWFW_PHY1_SM
        } else {
            SWFW_PHY0_SM
        };

        self.swfw_sync_mut(info, swfw, move |hw| {
            use PhyType::*;

            if matches!(hw.phy_type, Igp | Igp2 | Igp3) && reg_addr > MAX_PHY_MULTI_PAGE_REG {
                hw.write_phy_reg_ex(info, IGP01E1000_PHY_PAGE_SELECT, reg_addr as u16)?;
            } else if matches!(hw.phy_type, Gg82563) {
                if reg_addr & MAX_PHY_REG_ADDRESS > MAX_PHY_MULTI_PAGE_REG
                    || matches!(hw.mac_type, Em80003es2lan)
                {
                    // Select Configuration Page
                    if reg_addr & MAX_PHY_REG_ADDRESS < GG82563_MIN_ALT_REG {
                        hw.write_phy_reg_ex(
                            info,
                            GG82563_PHY_PAGE_SELECT,
                            (reg_addr >> GG82563_PAGE_SHIFT) as u16,
                        )?;
                    } else {
                        // Use Alternative Page Select register to access registers 30 and 31
                        hw.write_phy_reg_ex(
                            info,
                            GG82563_PHY_PAGE_SELECT_ALT,
                            (reg_addr >> GG82563_PAGE_SHIFT) as u16,
                        )?;
                    }
                }
            } else if matches!(hw.phy_type, Bm) && hw.phy_revision == Some(1) {
                if reg_addr > MAX_PHY_MULTI_PAGE_REG {
                    hw.write_phy_reg_ex(
                        info,
                        BM_PHY_PAGE_SELECT,
                        (reg_addr >> PHY_PAGE_SHIFT) as u16,
                    )?;
                }
            }

            hw.read_phy_reg_ex(info, MAX_PHY_REG_ADDRESS & reg_addr)
        })
    }

    /// Reads or writes the value from a PHY register, if the value is on a specific non zero page, sets the page first.
    /// https://github.com/openbsd/src/blob/d9ecc40d45e66a0a0b11c895967c9bb8f737e659/sys/dev/pci/if_em_hw.c#L5064
    fn access_phy_reg_hv_read(
        &mut self,
        info: &PCIeInfo,
        reg_addr: u32,
    ) -> Result<u16, IgbDriverErr> {
        let swfw = SWFW_PHY0_SM;

        self.swfw_sync_mut(info, swfw, |hw| {
            let page = bm_phy_reg_page(reg_addr);
            if page == BM_WUC_PAGE {
                let result = hw.access_phy_wakeup_reg_bm(info, reg_addr, true, None)?;
                return Ok(result.unwrap());
            }

            if page >= HV_INTC_FC_PAGE_START {
                hw.phy_addr = 1;
            } else {
                hw.phy_addr = 2;
            }

            let page = if page == HV_INTC_FC_PAGE_START {
                0
            } else {
                page
            };

            if reg_addr > MAX_PHY_MULTI_PAGE_REG {
                hw.write_phy_reg_ex(info, IGP01E1000_PHY_PAGE_SELECT, page << PHY_PAGE_SHIFT)?;
            }

            let reg = bm_phy_reg_num(reg_addr) as u32;
            let result = hw.read_phy_reg_ex(info, MAX_PHY_REG_ADDRESS & reg)?;

            Ok(result)
        })
    }

    fn access_phy_reg_hv_write(
        &mut self,
        info: &PCIeInfo,
        reg_addr: u32,
        phy_data: u16,
    ) -> Result<(), IgbDriverErr> {
        let swfw = SWFW_PHY0_SM;

        self.swfw_sync_mut(info, swfw, |hw| {
            let page = bm_phy_reg_page(reg_addr);
            if page == BM_WUC_PAGE {
                hw.access_phy_wakeup_reg_bm(info, reg_addr, false, Some(phy_data))?;
                return Ok(());
            }

            if page >= HV_INTC_FC_PAGE_START {
                hw.phy_addr = 1;
            } else {
                hw.phy_addr = 2;
            }

            let reg = bm_phy_reg_num(reg_addr) as u32;

            // Workaround MDIO accesses being disabled after entering IEEE Power
            // Down (whenever bit 11 of the PHY Control register is set)
            if matches!(hw.phy_type, PhyType::I82578)
                && matches!(hw.phy_revision, Some(1))
                && hw.phy_addr == 2
                && (MAX_PHY_REG_ADDRESS & reg) == 0
                && phy_data & (1 << 11) != 0
            {
                let data2 = 0x7EFF;
                hw.access_phy_debug_regs_hv(info, (1 << 6) | 0x3, Some(data2), false)?;
            }

            let page = if page == HV_INTC_FC_PAGE_START {
                0
            } else {
                page
            };

            if reg_addr > MAX_PHY_MULTI_PAGE_REG {
                hw.write_phy_reg_ex(info, IGP01E1000_PHY_PAGE_SELECT, page << PHY_PAGE_SHIFT)?;
            }

            hw.write_phy_reg_ex(info, MAX_PHY_REG_ADDRESS & reg, phy_data)?;

            Ok(())
        })
    }

    /// Read HV PHY vendor specific high registers
    pub fn access_phy_debug_regs_hv(
        &mut self,
        info: &PCIeInfo,
        reg_addr: u32,
        phy_data: Option<u16>,
        read: bool,
    ) -> Result<Option<u16>, IgbDriverErr> {
        // This takes care of the difference with desktop vs mobile phy
        let addr_reg = if matches!(self.phy_type, PhyType::I82578) {
            I82578_PHY_ADDR_REG
        } else {
            I82577_PHY_ADDR_REG
        };

        let data_reg = addr_reg + 1;

        // All operations in this function are phy address 2
        self.phy_addr = 2;

        // masking with 0x3F to remove the page from offset
        self.write_phy_reg_ex(info, addr_reg, (reg_addr & 0x3F) as u16)?;

        // Read or write the data value next
        if read {
            Ok(Some(self.read_phy_reg_ex(info, data_reg)?))
        } else {
            self.write_phy_reg_ex(info, data_reg, phy_data.unwrap())?;
            Ok(None)
        }
    }

    /// Read BM PHY wakeup register.  It works as such:
    /// 1) Set page 769, register 17, bit 2 = 1
    /// 2) Set page to 800 for host (801 if we were manageability)
    /// 3) Write the address using the address opcode (0x11)
    /// 4) Read or write the data using the data opcode (0x12)
    /// 5) Restore 769_17.2 to its original value
    fn access_phy_wakeup_reg_bm(
        &mut self,
        info: &PCIeInfo,
        reg_addr: u32,
        read: bool,
        write_data: Option<u16>,
    ) -> Result<Option<u16>, IgbDriverErr> {
        // All operations in this function are phy address 1
        self.phy_addr = 1;

        // Set page 769
        self.write_phy_reg_ex(
            info,
            IGP01E1000_PHY_PAGE_SELECT,
            BM_WUC_ENABLE_PAGE << PHY_PAGE_SHIFT,
        )?;

        let mut phy_reg = self.read_phy_reg_ex(info, BM_WUC_ENABLE_REG)?;

        // First clear bit 4 to avoid a power state change
        phy_reg &= !BM_WUC_HOST_WU_BIT;
        self.write_phy_reg_ex(info, BM_WUC_ENABLE_REG, phy_reg)?;

        // Write bit 2 = 1, and clear bit 4 to 769_17
        self.write_phy_reg_ex(info, BM_WUC_ENABLE_REG, phy_reg | BM_WUC_ENABLE_BIT)?;

        // Select page 800
        self.write_phy_reg_ex(
            info,
            IGP01E1000_PHY_PAGE_SELECT,
            BM_WUC_PAGE << PHY_PAGE_SHIFT,
        )?;

        // Write the page 800 offset value using opcode 0x11
        let reg = bm_phy_reg_num(reg_addr);
        self.write_phy_reg_ex(info, BM_WUC_ADDRESS_OPCODE, reg)?;

        let result = if read {
            // Read the page 800 value using opcode 0x12
            Some(self.read_phy_reg_ex(info, BM_WUC_DATA_OPCODE)?)
        } else {
            // Write the page 800 value using opcode 0x12
            self.write_phy_reg_ex(info, BM_WUC_DATA_OPCODE, write_data.unwrap())?;
            None
        };

        // Restore 769_17.2 to its original value
        // Set page 769
        self.write_phy_reg_ex(
            info,
            IGP01E1000_PHY_PAGE_SELECT,
            BM_WUC_ENABLE_PAGE << PHY_PAGE_SHIFT,
        )?;

        // Clear 769_17.2
        self.write_phy_reg_ex(info, BM_WUC_ENABLE_REG, phy_reg)?;

        Ok(result)
    }

    fn write_phy_reg_ex(
        &self,
        info: &PCIeInfo,
        reg_addr: u32,
        phy_data: u16,
    ) -> Result<(), IgbDriverErr> {
        // SGMII active is only set on some specific chips
        if self.sgmii_active && !self.sgmii_uses_mdio_82575(info)? {
            if reg_addr > super::MAX_SGMII_PHY_REG_ADDR {
                return Err(IgbDriverErr::Param);
            }
            return self.write_phy_reg_i2c(info, reg_addr, phy_data);
        }

        if reg_addr > MAX_PHY_REG_ADDRESS {
            return Err(IgbDriverErr::Param);
        }

        if matches!(self.mac_type, MacType::EmICPxxxx) {
            return Err(IgbDriverErr::NotSupported);
        }

        if self.mac_type.clone() as usize > MacType::Em82543 as usize {
            // Set up Op-code, Phy Address, register address, and data
            // intended for the PHY register in the MDI Control register.
            // The MAC will take care of interfacing with the PHY to send
            // the desired data.

            let mdic = ((phy_data as u32)
                | (reg_addr << super::MDIC_REG_SHIFT)
                | (self.phy_addr << super::MDIC_PHY_SHIFT)
                | (super::MDIC_OP_WRITE)) as u32;

            write_reg(info, super::MDIC, mdic)?;

            // Poll the ready bit to see if the MDI read completed
            let mut mdic = 0;
            for _ in 0..641 {
                awkernel_lib::delay::wait_microsec(5);
                mdic = read_reg(info, super::MDIC)?;
                if mdic & super::MDIC_READY != 0 {
                    break;
                }
            }

            if mdic & super::MDIC_READY == 0 {
                return Err(IgbDriverErr::Phy);
            }

            if matches!(
                self.mac_type,
                MacType::EmPch2lan
                    | MacType::EmPchLpt
                    | MacType::EmPchSpt
                    | MacType::EmPchCnp
                    | MacType::EmPchTgp
                    | MacType::EmPchAdp
            ) {
                awkernel_lib::delay::wait_microsec(100);
            }

            Ok(())
        } else {
            Err(IgbDriverErr::NotSupported)
        }
    }

    /// em_sgmii_uses_mdio_82575 - Determine if I2C pins are for external MDIO
    ///
    /// Called to determine if the I2C pins are being used for I2C or as an
    /// external MDIO interface since the two options are mutually exclusive.
    fn sgmii_uses_mdio_82575(&self, info: &PCIeInfo) -> Result<bool, IgbDriverErr> {
        match self.mac_type {
            MacType::Em82575 | MacType::Em82576 => {
                let reg = read_reg(info, super::MDIC)?;
                Ok(reg & super::MDIC_DEST != 0)
            }
            MacType::Em82580 | MacType::EmI350 | MacType::EmI210 => {
                let reg = read_reg(info, super::MDICNFG)?;
                Ok(reg & super::MDICNFG_EXT_MDIO != 0)
            }
            _ => Ok(false),
        }
    }

    /// em_write_phy_reg_i2c - Write PHY register using i2c.
    /// Writes the data to PHY register at the offset using the i2c interface.
    fn write_phy_reg_i2c(
        &self,
        info: &PCIeInfo,
        offset: u32,
        data: u16,
    ) -> Result<(), IgbDriverErr> {
        // Prevent overwriting SFP I2C EEPROM which is at A0 address.
        if self.phy_addr == 0 || self.phy_addr > 7 {
            log::warn!("igb: PHY I2C Address {} is out of range.", self.phy_addr);
            return Err(IgbDriverErr::Config);
        }

        // Swap the data bytes for the I2C interface
        let phy_data_swapped = ((data >> 8) & 0x00FF) | ((data << 8) & 0xFF00);

        // Set up Op-code, Phy Address, and register address in the I2CCMD
        // register.  The MAC will take care of interfacing with the
        // PHY to retrieve the desired data.
        let i2ccmd = (offset << super::I2CCMD_REG_ADDR_SHIFT)
            | (self.phy_addr << super::I2CCMD_PHY_ADDR_SHIFT)
            | super::I2CCMD_OPCODE_WRITE
            | phy_data_swapped as u32;

        write_reg(info, super::I2CCMD, i2ccmd)?;

        // Poll the ready bit to see if the I2C read completed
        let mut i2ccmd = 0;
        for _ in 0..super::I2CCMD_PHY_TIMEOUT {
            awkernel_lib::delay::wait_microsec(50);
            i2ccmd = read_reg(info, super::I2CCMD)?;
            if i2ccmd & super::I2CCMD_READY != 0 {
                break;
            }
        }

        if i2ccmd & super::I2CCMD_READY == 0 {
            log::warn!("igb: I2CCMD Write did not complete.");
            return Err(IgbDriverErr::Phy);
        }

        if i2ccmd & super::I2CCMD_ERROR != 0 {
            log::warn!("igb: I2CCMD Error bit set.");
            return Err(IgbDriverErr::Phy);
        }

        Ok(())
    }

    /// em_read_phy_reg_i2c - Read PHY register using i2c
    ///
    /// Reads the PHY register at offset using the i2c interface and stores the
    /// retrieved information in data.
    fn read_phy_reg_i2c(&self, info: &PCIeInfo, offset: u32) -> Result<u16, IgbDriverErr> {
        // Set up Op-code, Phy Address, and register address in the I2CCMD
        // register. The MAC will take care of interfacing with the
        // PHY to retrieve the desired data.
        let i2ccmd = (offset << super::I2CCMD_REG_ADDR_SHIFT)
            | (self.phy_addr << super::I2CCMD_PHY_ADDR_SHIFT)
            | super::I2CCMD_OPCODE_READ;

        write_reg(info, super::I2CCMD, i2ccmd)?;

        // Poll the ready bit to see if the I2C read completed
        let mut i2ccmd = 0;
        for _ in 0..super::I2CCMD_PHY_TIMEOUT {
            awkernel_lib::delay::wait_microsec(50);
            i2ccmd = read_reg(info, super::I2CCMD)?;
            if i2ccmd & super::I2CCMD_READY != 0 {
                break;
            }
        }

        if i2ccmd & super::I2CCMD_READY == 0 {
            log::warn!("igb: I2CCMD Read did not complete.");
            return Err(IgbDriverErr::Phy);
        }

        if i2ccmd & super::I2CCMD_ERROR != 0 {
            log::warn!("igb: I2CCMD Error bit set.");
            return Err(IgbDriverErr::Phy);
        }

        // Need to byte-swap the 16-bit value.
        let data = ((i2ccmd >> 8) & 0x00FF) | ((i2ccmd << 8) & 0xFF00);
        Ok(data as u16)
    }

    fn read_phy_reg_ex(&self, info: &PCIeInfo, reg_addr: u32) -> Result<u16, IgbDriverErr> {
        // SGMII active is only set on some specific chips
        if self.sgmii_active && !self.sgmii_uses_mdio_82575(info)? {
            if reg_addr > super::MAX_SGMII_PHY_REG_ADDR {
                return Err(IgbDriverErr::Param);
            }
            return self.read_phy_reg_i2c(info, reg_addr);
        }

        if reg_addr > MAX_PHY_REG_ADDRESS {
            return Err(IgbDriverErr::Param);
        }

        if matches!(self.mac_type, MacType::EmICPxxxx) {
            return Err(IgbDriverErr::NotSupported);
        }

        if self.mac_type.clone() as usize > MacType::Em82543 as usize {
            // Set up Op-code, Phy Address, and register address in the MDI Control register.
            // The MAC will take care of interfacing with the PHY to retrieve the desired data.
            let mdic = ((reg_addr << super::MDIC_REG_SHIFT)
                | (self.phy_addr << super::MDIC_PHY_SHIFT)
                | (super::MDIC_OP_READ)) as u32;

            write_reg(info, super::MDIC, mdic)?;

            // Poll the ready bit to see if the MDI read completed
            let mut mdic = 0;
            for _ in 0..1960 {
                awkernel_lib::delay::wait_microsec(50);
                mdic = read_reg(info, super::MDIC)?;
                if mdic & super::MDIC_READY != 0 {
                    break;
                }
            }

            if mdic & super::MDIC_READY == 0 {
                log::warn!("igb: MDI Read did not complete.");
                return Err(IgbDriverErr::Phy);
            }

            if mdic & super::MDIC_ERROR != 0 {
                log::warn!("igb: MDI Error bit set.");
                return Err(IgbDriverErr::Phy);
            }

            if matches!(
                self.mac_type,
                MacType::EmPch2lan
                    | MacType::EmPchLpt
                    | MacType::EmPchSpt
                    | MacType::EmPchCnp
                    | MacType::EmPchTgp
                    | MacType::EmPchAdp
            ) {
                awkernel_lib::delay::wait_microsec(100);
            }

            Ok(mdic as u16)
        } else {
            Err(IgbDriverErr::NotSupported)
        }
    }

    fn swfw_sync_mut<T, F>(&mut self, info: &PCIeInfo, mask: u16, f: F) -> Result<T, IgbDriverErr>
    where
        F: FnOnce(&mut Self) -> Result<T, IgbDriverErr>,
    {
        self.swfw_sync_acquire(info, mask)?;
        let result = f(self);
        self.swfw_sync_release(info, mask)?;
        result
    }

    /// https://github.com/openbsd/src/blob/d9ecc40d45e66a0a0b11c895967c9bb8f737e659/sys/dev/pci/if_em_hw.c#L4869
    fn swfw_sync_acquire(&mut self, info: &PCIeInfo, mask: u16) -> Result<(), IgbDriverErr> {
        if self.swfwhw_semaphore_present {
            return self.get_software_flag(info);
        }

        if !self.swfw_sync_present {
            return self.get_hw_eeprom_semaphore(info);
        }

        let mut swfw_sync = 0;
        let swmask = mask as u32;
        let fwmask = (mask as u32) << 16;
        let mut timeout = 200;

        while timeout > 0 {
            if self.get_hw_eeprom_semaphore(info).is_ok() {
                return Err(IgbDriverErr::SwfwSync);
            }

            swfw_sync = read_reg(info, super::SW_FW_SYNC)?;

            if swfw_sync & (fwmask | swmask) != 0 {
                break;
            }

            self.put_hw_eeprom_semaphore(info)?;
            awkernel_lib::delay::wait_millisec(5);
            timeout -= 1;
        }

        if timeout == 0 {
            log::warn!("igb: Driver can't access resource, SW_FW_SYNC timeout.");
            return Err(IgbDriverErr::SwfwSync);
        }

        swfw_sync |= swmask;
        write_reg(info, super::SW_FW_SYNC, swfw_sync)?;

        self.put_hw_eeprom_semaphore(info)?;

        Ok(())
    }

    fn swfw_sync_release(&mut self, info: &PCIeInfo, mask: u16) -> Result<(), IgbDriverErr> {
        if self.swfwhw_semaphore_present {
            return self.release_software_flag(info);
        }

        if !self.swfw_sync_present {
            return self.put_hw_eeprom_semaphore(info);
        }

        while self.get_hw_eeprom_semaphore(info).is_err() {}

        let swfw_sync = read_reg(info, super::SW_FW_SYNC)?;
        let swfw_sync = swfw_sync & !(mask as u32);
        write_reg(info, super::SW_FW_SYNC, swfw_sync)?;

        self.put_hw_eeprom_semaphore(info)
    }

    /// Using the combination of SMBI and SWESMBI semaphore bits when resetting adapter or Eeprom access.
    /// https://github.com/openbsd/src/blob/d9ecc40d45e66a0a0b11c895967c9bb8f737e659/sys/dev/pci/if_em_hw.c#L9719
    fn get_hw_eeprom_semaphore(&self, info: &PCIeInfo) -> Result<(), IgbDriverErr> {
        if self.eeprom_semaphore_present {
            return Ok(());
        }

        if matches!(self.mac_type, MacType::Em80003es2lan) {
            // Get the SW semaphore.
            return self.get_software_semaphore(info);
        }

        // Get the FW semaphore.
        let mut timeout = self.eeprom.word_size + 1;

        while timeout > 0 {
            let swsm = read_reg(info, super::SWSM)? | super::SWSM_SWESMBI;
            write_reg(info, super::SWSM, swsm)?;

            // If we managed to set the bit we got the semaphore.
            let swsm = read_reg(info, super::SWSM)?;
            if swsm & super::SWSM_SWESMBI != 0 {
                break;
            }

            awkernel_lib::delay::wait_microsec(50);
            timeout -= 1;
        }

        if timeout == 0 {
            // Release semaphores
            self.put_hw_eeprom_semaphore(info)?;
            log::warn!("igb: Driver can't access the Eeprom - SWESMBI bit is set.");
            return Err(IgbDriverErr::Reset);
        } else {
            Ok(())
        }
    }

    fn put_hw_eeprom_semaphore(&self, info: &PCIeInfo) -> Result<(), IgbDriverErr> {
        if !self.eeprom_semaphore_present {
            return Ok(());
        }

        let swsm = read_reg(info, super::SWSM)?;
        if matches!(self.mac_type, MacType::Em80003es2lan) {
            // Release both semaphores.
            write_reg(
                info,
                super::SWSM,
                swsm & !(super::SWSM_SMBI | super::SWSM_SWESMBI),
            )?;
        } else {
            write_reg(info, super::SWSM, swsm & !(super::SWSM_SWESMBI))?;
        };

        Ok(())
    }

    /// Release semaphore bit (SMBI).
    fn release_software_semaphore(&self, info: &PCIeInfo) -> Result<(), IgbDriverErr> {
        if !matches!(self.mac_type, MacType::Em80003es2lan) {
            return Ok(());
        }

        let swsm = read_reg(info, super::SWSM)?;

        // Release the SW semaphores.
        let swsm = swsm & !super::SWSM_SMBI;
        write_reg(info, super::SWSM, swsm)?;

        Ok(())
    }

    /// Obtaining software semaphore bit (SMBI) before resetting PHY.
    fn get_software_semaphore(&self, info: &PCIeInfo) -> Result<(), IgbDriverErr> {
        if matches!(self.mac_type, MacType::Em80003es2lan) {
            return Ok(());
        }

        let mut timeout = self.eeprom.word_size + 1;
        while timeout > 0 {
            let swsm = read_reg(info, super::SWSM)?;

            // If SMBI bit cleared, it is now set and we hold the semaphore
            if swsm & super::SWSM_SMBI == 0 {
                break;
            }

            awkernel_lib::delay::wait_millisec(1);
            timeout -= 1;
        }

        if timeout == 0 {
            log::warn!("igb: Driver can't access device - SMBI bit is set.");
            Err(IgbDriverErr::Reset)
        } else {
            Ok(())
        }
    }

    /// Get software semaphore FLAG bit (SWFLAG).
    /// SWFLAG is used to synchronize the access to all shared resource between
    /// SW, FW and HW.
    fn get_software_flag(&mut self, info: &PCIeInfo) -> Result<(), IgbDriverErr> {
        let mut timeout = SW_FLAG_TIMEOUT;

        if is_ich8(&self.mac_type) {
            if self.sw_flag != 0 {
                self.sw_flag -= 1;
                return Ok(());
            }

            let mut extcnf_ctrl = 0;
            while timeout > 0 {
                extcnf_ctrl = read_reg(info, super::EXTCNF_CTRL)?;

                if extcnf_ctrl & super::EXTCNF_CTRL_SWFLAG == 0 {
                    break;
                }

                awkernel_lib::delay::wait_millisec(1);
                timeout -= 1;
            }

            if timeout == 0 {
                log::warn!("igb: SW has already locked the resource?");
                return Err(IgbDriverErr::Config);
            }

            timeout = SW_FLAG_TIMEOUT;
            extcnf_ctrl |= super::EXTCNF_CTRL_SWFLAG;
            write_reg(info, super::EXTCNF_CTRL, extcnf_ctrl)?;

            while timeout > 0 {
                extcnf_ctrl = read_reg(info, super::EXTCNF_CTRL)?;

                if extcnf_ctrl & super::EXTCNF_CTRL_SWFLAG != 0 {
                    break;
                }

                awkernel_lib::delay::wait_millisec(1);
                timeout -= 1;
            }

            if timeout == 0 {
                log::warn!("igb: Failed to acquire the semaphore, FW or HW has it.");
                extcnf_ctrl &= !super::EXTCNF_CTRL_SWFLAG;
                write_reg(info, super::EXTCNF_CTRL, extcnf_ctrl)?;
                return Err(IgbDriverErr::Config);
            }
        }

        self.sw_flag += 1;

        Ok(())
    }

    /// Checks if PHY reset is blocked due to SOL/IDER session, for example.
    /// Returning E1000_BLK_PHY_RESET isn't necessarily an error.  But it's up to
    /// the caller to figure out how to deal with it.
    fn check_phy_reset_block(&self, info: &PCIeInfo) -> Result<(), IgbDriverErr> {
        if is_ich8(&self.mac_type) {
            let mut i = 0;
            let mut blocked = true;

            while blocked && i < 30 {
                let fwsm = read_reg(info, super::FWSM)?;
                i += 1;

                if (fwsm & super::FWSM_RSPCIPHY) == 0 {
                    blocked = true;
                    awkernel_lib::delay::wait_millisec(10);
                } else {
                    blocked = false;
                }
            }

            if blocked {
                return Err(IgbDriverErr::PhyReset);
            } else {
                return Ok(());
            }
        }

        let manc = if self.mac_type.clone() as u32 > MacType::Em82547Rev2 as u32 {
            read_reg(info, super::MANC)?
        } else {
            0
        };

        if manc & super::MANC_BLK_PHY_RST_ON_IDE != 0 {
            Err(IgbDriverErr::PhyReset)
        } else {
            Ok(())
        }
    }

    /// e1000_gate_hw_phy_config_ich8lan - disable PHY config via hardware
    /// - gate: boolean set to TRUE to gate, FALSE to ungate
    ///
    /// Gate/ungate the automatic PHY configuration via hardware; perform
    /// the configuration via software instead.
    fn gate_hw_phy_config_ich8lan(&self, info: &PCIeInfo, gate: bool) -> Result<(), IgbDriverErr> {
        if !matches!(self.mac_type, MacType::EmPch2lan) {
            return Ok(());
        }

        let mut extcnf_ctrl = read_reg(info, super::EXTCNF_CTRL)?;

        if gate {
            extcnf_ctrl |= super::EXTCNF_CTRL_GATE_PHY_CFG
        } else {
            extcnf_ctrl &= !super::EXTCNF_CTRL_GATE_PHY_CFG;
        }

        write_reg(info, super::EXTCNF_CTRL, extcnf_ctrl)?;

        Ok(())
    }
}

const MASTER_DISABLE_TIMEOUT: u32 = 800;

/// The defaults for 82575 and 82576 should be in the range of 50us to 50ms,
/// however the hardware default for these parts is 500us to 1ms which is less
/// than the 10ms recommended by the pci-e spec.  To address this we need to
/// increase the value to either 10ms to 200ms for capability version 1 config,
/// or 16ms to 55ms for version 2.
fn set_pciex_completion_timeout(info: &PCIeInfo) -> Result<(), IgbDriverErr> {
    let mut gcr = read_reg(info, super::GCR)?;

    // Only take action if timeout value is not set by system BIOS
    //
    // If capabilities version is type 1 we can write the
    // timeout of 10ms to 200ms through the GCR register
    if gcr & super::GCR_CMPL_TMOUT_MASK == 0 && gcr & super::GCR_CAP_VER2 != 0 {
        gcr |= super::GCR_CMPL_TMOUT_10_MS;
    }

    // Disable completion timeout resend
    gcr &= super::GCR_CMPL_TMOUT_RESEND;

    write_reg(info, super::GCR, gcr)?;

    Ok(())
}

/// https://github.com/openbsd/src/blob/da407c5b03f3f213fdfa21192733861c3bdeeb5f/sys/dev/pci/if_em_hw.c#L9559
fn disable_pciex_master(info: &PCIeInfo) -> Result<(), IgbDriverErr> {
    set_pcie_express_master_disable(info)?;

    for _ in 0..MASTER_DISABLE_TIMEOUT {
        if read_reg(info, super::CTRL)? & super::CTRL_GIO_MASTER_DISABLE != 0 {
            return Ok(());
        }
    }

    Err(IgbDriverErr::MasterDisableTimeout)
}

/// https://github.com/openbsd/src/blob/da407c5b03f3f213fdfa21192733861c3bdeeb5f/sys/dev/pci/if_em_hw.c#L9533
fn set_pcie_express_master_disable(info: &PCIeInfo) -> Result<(), IgbDriverErr> {
    let ctrl = read_reg(info, super::CTRL)?;
    write_reg(info, super::CTRL, ctrl | super::CTRL_GIO_MASTER_DISABLE)?;

    Ok(())
}

#[derive(Debug, Clone)]
enum EEPROMType {
    Microwire,
    SPI,
    Flash,
    Ich8,
    Invm,
}

#[derive(Debug)]
struct EEPROM {
    eeprom_type: EEPROMType,
    page_size: Option<u16>,
    word_size: u16,
    address_bits: u16,
    delay_usec: u16,
    opcode_bits: u16,
    use_eerd: bool,
    use_eewr: bool,
}

/* EEPROM/Flash Control */
const E1000_EECD_SK: u32 = 0x00000001; /* EEPROM Clock */
const E1000_EECD_CS: u32 = 0x00000002; /* EEPROM Chip Select */
const E1000_EECD_DI: u32 = 0x00000004; /* EEPROM Data In */
const E1000_EECD_DO: u32 = 0x00000008; /* EEPROM Data Out */
const E1000_EECD_FWE_MASK: u32 = 0x00000030;
const E1000_EECD_FWE_DIS: u32 = 0x00000010; /* Disable FLASH writes */
const E1000_EECD_FWE_EN: u32 = 0x00000020; /* Enable FLASH writes */
const E1000_EECD_FWE_SHIFT: u32 = 4;
const E1000_EECD_REQ: u32 = 0x00000040; /* EEPROM Access Request */
const E1000_EECD_GNT: u32 = 0x00000080; /* EEPROM Access Grant */
const E1000_EECD_PRES: u32 = 0x00000100; /* EEPROM Present */
const E1000_EECD_SIZE: u32 = 0x00000200; // EEPROM Size (0=64 word 1=256 word)
const E1000_EECD_ADDR_BITS: u32 = 0x00000400; // EEPROM Addressing bits based on type
const E1000_EECD_TYPE: u32 = 0x00002000;
const E1000_EECD_FLUPD: u32 = 0x00080000;
const E1000_EECD_AUPDEN: u32 = 0x00100000;

const E1000_EEPROM_GRANT_ATTEMPTS: u32 = 1000; // EEPROM # attempts to gain grant

const E1000_EECD_SIZE_EX_MASK: u32 = 0x00007800;
const E1000_EECD_SIZE_EX_SHIFT: u32 = 11;
const EEPROM_WORD_SIZE_SHIFT: u32 = 6;
const EEPROM_WORD_SIZE_SHIFT_MAX: u32 = 14;

const E1000_SHADOW_RAM_WORDS: u16 = 2048;

const INVM_SIZE: u16 = 64;

const ICH_FLASH_GFPREG: usize = 0x0000;

const ICH_GFPREG_BASE_MASK: u32 = 0x1FFF;
const ICH_FLASH_SECTOR_SIZE: u32 = 4096;

impl EEPROM {
    /// Return `(EEPROM, flash_base_address, flash_bank_size)`.
    ///
    /// https://github.com/openbsd/src/blob/8e9ff1e61e136829a715052f888f67d3617fc787/sys/dev/pci/if_em_hw.c#L6280
    fn new(
        mac_type: &MacType,
        flash_memory: &Option<(BaseAddress, usize)>,
        info: &PCIeInfo,
    ) -> Result<(Self, Option<usize>, Option<usize>), IgbDriverErr> {
        use MacType::*;

        let mut bar0 = info.get_bar(0).ok_or(IgbDriverErr::NoBar0)?;
        let eecd = bar0.read(super::EECD).ok_or(IgbDriverErr::ReadFailure)?;

        let mut result = match mac_type {
            Em82542Rev2_0 | Em82542Rev2_1 | Em82543 | Em82544 => (
                Self {
                    eeprom_type: EEPROMType::Microwire,
                    page_size: None,
                    word_size: 64,
                    address_bits: 6,
                    delay_usec: 50,
                    opcode_bits: 3,
                    use_eerd: false,
                    use_eewr: false,
                },
                None,
                None,
            ),
            Em82540 | Em82545 | Em82545Rev3 | Em82546 | Em82546Rev3 => {
                let (word_size, address_bits) = if eecd & E1000_EECD_SIZE != 0 {
                    (256, 8)
                } else {
                    (64, 6)
                };

                (
                    Self {
                        eeprom_type: EEPROMType::Microwire,
                        opcode_bits: 3,
                        page_size: None,
                        delay_usec: 50,
                        word_size,
                        address_bits,
                        use_eerd: false,
                        use_eewr: false,
                    },
                    None,
                    None,
                )
            }
            Em82541 | Em82541Rev2 | Em82547 | Em82547Rev2 => {
                if eecd & E1000_EECD_TYPE != 0 {
                    let (page_size, address_bits) = if eecd & E1000_EECD_ADDR_BITS != 0 {
                        (32, 16)
                    } else {
                        (8, 8)
                    };

                    (
                        Self {
                            eeprom_type: EEPROMType::SPI,
                            opcode_bits: 8,
                            delay_usec: 1,
                            page_size: Some(page_size),
                            word_size: 0, // SPI's word size will be set later.
                            address_bits,
                            use_eerd: false,
                            use_eewr: false,
                        },
                        None,
                        None,
                    )
                } else {
                    let (word_size, address_bits) = if eecd & E1000_EECD_ADDR_BITS != 0 {
                        (256, 8)
                    } else {
                        (64, 6)
                    };

                    (
                        Self {
                            eeprom_type: EEPROMType::Microwire,
                            opcode_bits: 3,
                            delay_usec: 50,
                            page_size: None,
                            word_size,
                            address_bits,
                            use_eerd: false,
                            use_eewr: false,
                        },
                        None,
                        None,
                    )
                }
            }
            Em82571 | Em82572 => {
                let (page_size, address_bits) = if eecd & E1000_EECD_ADDR_BITS != 0 {
                    (32, 16)
                } else {
                    (8, 8)
                };

                (
                    Self {
                        eeprom_type: EEPROMType::SPI,
                        opcode_bits: 8,
                        delay_usec: 1,
                        word_size: 0, // SPI's word size will be set later.
                        page_size: Some(page_size),
                        address_bits,
                        use_eerd: false,
                        use_eewr: false,
                    },
                    None,
                    None,
                )
            }
            Em82573 | Em82574 | Em82575 | Em82576 | Em82580 | EmI210 | EmI350 => {
                let (page_size, address_bits) = if eecd & E1000_EECD_ADDR_BITS != 0 {
                    (32, 16)
                } else {
                    (8, 8)
                };

                let (eeprom_type, word_size, use_eerd, use_eewr) =
                    if !get_flash_presence_i210(mac_type, info)? {
                        (EEPROMType::Invm, INVM_SIZE, false, false)
                    } else if !is_onboard_nvm_eeprom(mac_type, info)? {
                        let eecd = eecd & !E1000_EECD_AUPDEN;
                        bar0.write(super::EECD, eecd);

                        (EEPROMType::Flash, 2048, true, true)
                    } else {
                        // SPI's word size will be set later.
                        (EEPROMType::SPI, 0, true, true)
                    };

                (
                    Self {
                        eeprom_type,
                        opcode_bits: 8,
                        delay_usec: 1,
                        page_size: Some(page_size),
                        word_size,
                        address_bits,
                        use_eerd,
                        use_eewr,
                    },
                    None,
                    None,
                )
            }
            Em80003es2lan => {
                let (page_size, address_bits) = if eecd & E1000_EECD_ADDR_BITS != 0 {
                    (32, 16)
                } else {
                    (8, 8)
                };

                (
                    Self {
                        eeprom_type: EEPROMType::SPI,
                        opcode_bits: 8,
                        delay_usec: 1,
                        page_size: Some(page_size),
                        word_size: 0, // SPI's word size will be set later.
                        address_bits,
                        use_eerd: true,
                        use_eewr: false,
                    },
                    None,
                    None,
                )
            }
            EmIch8lan | EmIch9lan | EmIch10lan | EmPchlan | EmPch2lan | EmPchLpt => {
                let (flash_memory, offset) =
                    flash_memory.as_ref().ok_or(IgbDriverErr::ReadFailure)?;

                let flash_size = flash_memory
                    .read(*offset + ICH_FLASH_GFPREG)
                    .ok_or(IgbDriverErr::ReadFailure)?;

                // https://github.com/openbsd/src/blob/4ff40062e57fb8a42d28dcb700c25b8254514628/sys/dev/pci/if_em_hw.c#L6434C12-L6434C29
                // `eeprom_shadow_ram` may not be used?

                let flash_base_addr = (flash_size & ICH_GFPREG_BASE_MASK) * ICH_FLASH_SECTOR_SIZE;

                let mut flash_bank_size = ((flash_size >> 16) & ICH_GFPREG_BASE_MASK) + 1;
                flash_bank_size -= flash_size & ICH_GFPREG_BASE_MASK;
                flash_bank_size *= ICH_FLASH_SECTOR_SIZE;
                flash_bank_size /= 2 * core::mem::size_of::<u16>() as u32;

                (
                    Self {
                        eeprom_type: EEPROMType::Ich8,
                        opcode_bits: 0,
                        delay_usec: 0,
                        page_size: None,
                        word_size: E1000_SHADOW_RAM_WORDS,
                        address_bits: 0,
                        use_eerd: false,
                        use_eewr: false,
                    },
                    Some(flash_base_addr as usize),
                    Some(flash_bank_size as usize),
                )
            }
            EmPchSpt | EmPchCnp | EmPchTgp | EmPchAdp => {
                let flash_size = bar0
                    .read(0xc /* STRAP */)
                    .ok_or(IgbDriverErr::ReadFailure)?;

                let mut flash_size = (flash_size >> 1 & 0x1f) + 1;
                flash_size *= 1024;

                (
                    Self {
                        eeprom_type: EEPROMType::Ich8,
                        opcode_bits: 0,
                        delay_usec: 0,
                        page_size: None,
                        word_size: E1000_SHADOW_RAM_WORDS,
                        address_bits: 0,
                        use_eerd: false,
                        use_eewr: false,
                    },
                    Some(0),
                    Some(flash_size as usize),
                )
            }
            EmICPxxxx => {
                return Err(IgbDriverErr::NotSupported);
            }
        };

        if matches!(result.0.eeprom_type, EEPROMType::SPI) {
            if mac_type.clone() as u32 <= Em82547Rev2 as u32 {
                return Err(IgbDriverErr::NotSupported);
            }

            let eecd = bar0.read(super::EECD).ok_or(IgbDriverErr::ReadFailure)?;
            let eeprom_size = (eecd & E1000_EECD_SIZE_EX_MASK) >> E1000_EECD_SIZE_EX_SHIFT;

            // EEPROM access above 16k is unsupported
            if eeprom_size + EEPROM_WORD_SIZE_SHIFT > EEPROM_WORD_SIZE_SHIFT_MAX {
                result.0.word_size = 1 << EEPROM_WORD_SIZE_SHIFT_MAX;
            } else {
                result.0.word_size = 1 << (eeprom_size + EEPROM_WORD_SIZE_SHIFT);
            }
        }

        Ok(result)
    }
}

fn is_onboard_nvm_eeprom(mac_type: &MacType, info: &PCIeInfo) -> Result<bool, IgbDriverErr> {
    use MacType::*;

    if is_ich8(mac_type) {
        return Ok(false);
    }

    if matches!(mac_type, Em82573 | Em82574) {
        let eecd = read_reg(info, super::EECD)?;

        // Isolate bits 15 & 16
        let eecd = (eecd >> 15) & 0x03;

        // If both bits are set, device is Flash type
        if eecd == 0x03 {
            return Ok(false);
        }
    }

    Ok(true)
}

fn get_flash_presence_i210(mac_type: &MacType, info: &PCIeInfo) -> Result<bool, IgbDriverErr> {
    if matches!(mac_type, MacType::EmI210) {
        return Ok(true);
    }

    let eecd = read_reg(info, super::EECD)?;

    if eecd & E1000_EECD_FLUPD != 0 {
        Ok(true)
    } else {
        Ok(false)
    }
}

/// Set media type and TBI compatibility.
/// Return `(tbi_compatibility_en, media_type, sgmii_active)`.
fn set_media_type(
    mac_type: &MacType,
    info: &PCIeInfo,
) -> Result<(bool, MediaType, bool), IgbDriverErr> {
    use MacType::*;

    let mut tbi_compatibility_en = true;
    let mut sgmii_active = false;

    if matches!(mac_type, Em82543) {
        // tbi_compatibility is only valid on 82543
        tbi_compatibility_en = false;
    }

    if matches!(mac_type, Em82575 | Em82580 | Em82576 | EmI210 | EmI350) {
        let mut media_type = MediaType::Copper;
        let mut ctrl_ext = read_reg(info, super::CTRL_EXT)?;
        let mode = ctrl_ext & super::CTRL_EXT_LINK_MODE_MASK;

        match mode {
            super::CTRL_EXT_LINK_MODE_1000BASE_KX => {
                media_type = MediaType::InternalSerdes;
                ctrl_ext |= super::CTRL_I2C_ENA;
            }
            super::CTRL_EXT_LINK_MODE_SGMII | super::CTRL_EXT_LINK_MODE_PCIE_SERDES => {
                if mode == super::CTRL_EXT_LINK_MODE_SGMII {
                    let mdic = read_reg(info, super::MDICNFG)?;

                    ctrl_ext |= super::CTRL_I2C_ENA;

                    if mdic & super::MDICNFG_EXT_MDIO != 0 {
                        sgmii_active = true;
                    }
                }

                ctrl_ext |= super::CTRL_I2C_ENA;

                match set_sfp_media_type_82575(info) {
                    Ok((media_type_ret, sgmii_active_ret)) => {
                        media_type = media_type_ret;
                        sgmii_active = sgmii_active_ret;
                    }
                    _ => {
                        media_type = MediaType::InternalSerdes;

                        if (ctrl_ext & super::CTRL_EXT_LINK_MODE_MASK)
                            == super::CTRL_EXT_LINK_MODE_SGMII
                        {
                            media_type = MediaType::Copper;
                            sgmii_active = true;
                        }
                    }
                }

                ctrl_ext &= !super::CTRL_EXT_LINK_MODE_MASK;

                if sgmii_active {
                    ctrl_ext |= super::CTRL_EXT_LINK_MODE_SGMII;
                } else {
                    ctrl_ext |= super::CTRL_EXT_LINK_MODE_PCIE_SERDES;
                }
            }
            _ => {
                ctrl_ext &= !super::CTRL_I2C_ENA;
            }
        }

        write_reg(info, super::CTRL_EXT, ctrl_ext)?;
        return Ok((tbi_compatibility_en, media_type, sgmii_active));
    }

    match info.get_id() {
        E1000_DEV_ID_82545GM_SERDES
        | E1000_DEV_ID_82546GB_SERDES
        | E1000_DEV_ID_82571EB_SERDES
        | E1000_DEV_ID_82571EB_SERDES_DUAL
        | E1000_DEV_ID_82571EB_SERDES_QUAD
        | E1000_DEV_ID_82572EI_SERDES
        | E1000_DEV_ID_80003ES2LAN_SERDES_DPT => Ok((
            tbi_compatibility_en,
            MediaType::InternalSerdes,
            sgmii_active,
        )),
        E1000_DEV_ID_EP80579_LAN_1
        | E1000_DEV_ID_EP80579_LAN_2
        | E1000_DEV_ID_EP80579_LAN_3
        | E1000_DEV_ID_EP80579_LAN_4
        | E1000_DEV_ID_EP80579_LAN_5
        | E1000_DEV_ID_EP80579_LAN_6 => Ok((tbi_compatibility_en, MediaType::Copper, sgmii_active)),
        _ => match mac_type {
            Em82542Rev2_0 | Em82542Rev2_1 => {
                Ok((tbi_compatibility_en, MediaType::Fiber, sgmii_active))
            }
            EmIch8lan | EmIch9lan | EmIch10lan | EmPchlan | EmPch2lan | EmPchLpt | EmPchSpt
            | EmPchCnp | EmPchTgp | EmPchAdp | Em82573 | Em82574 => {
                Ok((tbi_compatibility_en, MediaType::Copper, sgmii_active))
            }
            _ => {
                let status = read_reg(info, super::STATUS)?;

                if status & super::STATUS_TBIMODE != 0 {
                    // tbi_compatibility is not valid on fiber
                    Ok((false, MediaType::Fiber, sgmii_active))
                } else {
                    Ok((tbi_compatibility_en, MediaType::Copper, sgmii_active))
                }
            }
        },
    }
}

bitflags::bitflags! {
    // Flags for SFP modules compatible with ETH up to 1Gb
    struct SfpE1000Flags: u8 {
        const E1000_BASE_SX = 1;
        const E1000_BASE_LX = 1 << 1;
        const E1000_BASE_CX = 1 << 2;
        const E1000_BASE_T = 1 << 3;
        const E100_BASE_LX = 1 << 4;
        const E100_BASE_FX = 1 << 5;
        const E10_BASE_BX10 = 1 << 6;
        const E10_BASE_PX = 1 << 7;
    }
}

/// em_set_sfp_media_type_82575 - derives SFP module media type.
/// Return `(media_type, sgmii_active)`.
fn set_sfp_media_type_82575(info: &PCIeInfo) -> Result<(MediaType, bool), IgbDriverErr> {
    // Turn I2C interface ON and power on sfp cage
    let ctrl_ext = read_reg(info, super::CTRL_EXT)?;
    let ctrl_ext = ctrl_ext & !super::CTRL_EXT_SDP3_DATA;
    write_reg(info, super::CTRL_EXT, ctrl_ext)?;

    write_flush(info)?;

    // Read SFP module data
    let mut timeout = 3;
    let mut transceiver_type = 0;
    while timeout > 0 {
        match read_sfp_data_byte(info, i2ccd_sfp_data_addr(super::SFF_IDENTIFIER_OFFSET)) {
            Ok(val) => {
                transceiver_type = val;
                break;
            }
            Err(_) => {
                awkernel_lib::delay::wait_millisec(100);
                timeout -= 1;
            }
        }
    }

    if timeout == 0 {
        write_reg(info, super::CTRL_EXT, ctrl_ext)?;
        return Err(IgbDriverErr::Phy);
    }

    let Ok(eth_flags) = read_sfp_data_byte(info, i2ccd_sfp_data_addr(super::SFF_ETH_FLAGS_OFFSET))
    else {
        write_reg(info, super::CTRL_EXT, ctrl_ext)?;
        return Err(IgbDriverErr::Phy);
    };

    let eth_flags = SfpE1000Flags::from_bits_truncate(eth_flags);

    // Check if there is some SFP module plugged and powered
    let result = if transceiver_type == super::SFF_IDENTIFIER_SFP
        || transceiver_type == super::SFF_IDENTIFIER_SFF
    {
        if eth_flags.contains(SfpE1000Flags::E1000_BASE_LX)
            || eth_flags.contains(SfpE1000Flags::E1000_BASE_SX)
        {
            (MediaType::InternalSerdes, false)
        } else if eth_flags.contains(SfpE1000Flags::E100_BASE_FX)
            || eth_flags.contains(SfpE1000Flags::E100_BASE_LX)
        {
            (MediaType::InternalSerdes, true)
        } else if eth_flags.contains(SfpE1000Flags::E1000_BASE_T) {
            (MediaType::Copper, true)
        } else {
            write_reg(info, super::CTRL_EXT, ctrl_ext)?;
            return Err(IgbDriverErr::Config);
        }
    } else {
        write_reg(info, super::CTRL_EXT, ctrl_ext)?;
        return Err(IgbDriverErr::Config);
    };

    write_reg(info, super::CTRL_EXT, ctrl_ext)?;
    Ok(result)
}

fn read_sfp_data_byte(info: &PCIeInfo, offset: u32) -> Result<u8, IgbDriverErr> {
    if offset > i2ccd_sfp_data_addr(255) {
        return Err(IgbDriverErr::Phy);
    }

    // Set up Op-code, EEPROM Address, in the I2CCMD register.
    // The MAC will take care of interfacing with the EEPROM to retrieve the desired data.
    let i2ccmd = (offset << super::I2CCMD_REG_ADDR_SHIFT) | super::I2CCMD_OPCODE_READ;
    write_reg(info, super::I2CCMD, i2ccmd)?;

    let mut data_local = 0;

    // Poll the ready bit to see if the I2C read completed
    for _ in 0..super::I2CCMD_PHY_TIMEOUT {
        awkernel_lib::delay::wait_microsec(50);

        data_local = read_reg(info, super::I2CCMD)?;
        if data_local & super::I2CCMD_READY != 0 {
            break;
        }
    }

    if data_local & super::I2CCMD_READY == 0 {
        return Err(IgbDriverErr::Phy);
    }

    if data_local & super::I2CCMD_ERROR != 0 {
        return Err(IgbDriverErr::Phy);
    }

    Ok((data_local & 0xFF) as u8)
}

fn i2ccd_sfp_data_addr(a: u32) -> u32 {
    0x100 + a
}

#[inline(always)]
fn write_reg(info: &PCIeInfo, offset: usize, value: u32) -> Result<(), IgbDriverErr> {
    let mut bar0 = info.get_bar(0).ok_or(IgbDriverErr::NoBar0)?;
    bar0.write(offset, value);
    Ok(())
}

#[inline(always)]
fn read_reg(info: &PCIeInfo, offset: usize) -> Result<u32, IgbDriverErr> {
    let bar0 = info.get_bar(0).ok_or(IgbDriverErr::NoBar0)?;
    Ok(bar0.read(offset).ok_or(IgbDriverErr::ReadFailure)?)
}

#[inline(always)]
fn write_flush(info: &PCIeInfo) -> Result<(), IgbDriverErr> {
    let bar0 = info.get_bar(0).ok_or(IgbDriverErr::NoBar0)?;
    bar0.read(super::STATUS).ok_or(IgbDriverErr::ReadFailure)?;
    Ok(())
}

fn bm_phy_reg_num(offset: u32) -> u16 {
    ((offset & MAX_PHY_REG_ADDRESS)
        | ((offset >> (PHY_UPPER_SHIFT - PHY_PAGE_SHIFT)) & !MAX_PHY_REG_ADDRESS)) as u16
}

fn bm_phy_reg_page(offset: u32) -> u16 {
    ((offset >> PHY_PAGE_SHIFT) & 0xFFFF) as u16
}
